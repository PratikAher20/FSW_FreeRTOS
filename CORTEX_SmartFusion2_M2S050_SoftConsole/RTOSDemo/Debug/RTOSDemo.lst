
RTOSDemo:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002b10  20000000  20000000  00008000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  20002b10  20002b10  0000ab10  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000910  20002b18  20002b18  0000ab18  2**2
                  ALLOC
  3 .stack        00000400  20003428  20003428  0000ab18  2**0
                  ALLOC
  4 .comment      00000489  00000000  00000000  0000ab18  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000d08  00000000  00000000  0000afa1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000211c  00000000  00000000  0000bca9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00010bd7  00000000  00000000  0000ddc5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000282c  00000000  00000000  0001e99c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0001283b  00000000  00000000  000211c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00002b5c  00000000  00000000  00033a04  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00004f27  00000000  00000000  00036560  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00004863  00000000  00000000  0003b487  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macinfo 000d6f94  00000000  00000000  0003fcea  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .ARM.attributes 00000025  00000000  00000000  00116c7e  2**0
                  CONTENTS, READONLY
 15 .debug_ranges 00000ca8  00000000  00000000  00116ca3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

20000000 <__text_start>:
20000000:	20010000 	.word	0x20010000
20000004:	20000189 	.word	0x20000189
20000008:	200001f9 	.word	0x200001f9
2000000c:	200001fb 	.word	0x200001fb
20000010:	200001fd 	.word	0x200001fd
20000014:	200001ff 	.word	0x200001ff
20000018:	20000201 	.word	0x20000201
	...
2000002c:	200008b1 	.word	0x200008b1
20000030:	20000205 	.word	0x20000205
20000034:	00000000 	.word	0x00000000
20000038:	200008e1 	.word	0x200008e1
2000003c:	20000931 	.word	0x20000931
20000040:	2000020b 	.word	0x2000020b
20000044:	2000020d 	.word	0x2000020d
20000048:	2000020f 	.word	0x2000020f
2000004c:	20000211 	.word	0x20000211
20000050:	2000180d 	.word	0x2000180d
20000054:	20000215 	.word	0x20000215
20000058:	20000217 	.word	0x20000217
2000005c:	20001831 	.word	0x20001831
20000060:	2000021b 	.word	0x2000021b
20000064:	2000021d 	.word	0x2000021d
20000068:	20000c41 	.word	0x20000c41
2000006c:	20000c65 	.word	0x20000c65
20000070:	20000223 	.word	0x20000223
20000074:	20000225 	.word	0x20000225
20000078:	20000227 	.word	0x20000227
2000007c:	20000229 	.word	0x20000229
20000080:	2000022b 	.word	0x2000022b
20000084:	2000022d 	.word	0x2000022d
20000088:	2000022f 	.word	0x2000022f
2000008c:	20000231 	.word	0x20000231
20000090:	20000233 	.word	0x20000233
20000094:	20000235 	.word	0x20000235
20000098:	20000237 	.word	0x20000237
2000009c:	20000239 	.word	0x20000239
200000a0:	2000023b 	.word	0x2000023b
200000a4:	2000023d 	.word	0x2000023d
200000a8:	2000023f 	.word	0x2000023f
200000ac:	20000241 	.word	0x20000241
200000b0:	20000243 	.word	0x20000243
200000b4:	20000245 	.word	0x20000245
200000b8:	20000247 	.word	0x20000247
200000bc:	20000249 	.word	0x20000249
200000c0:	2000024b 	.word	0x2000024b
200000c4:	2000024d 	.word	0x2000024d
200000c8:	20000b89 	.word	0x20000b89
200000cc:	20000b9d 	.word	0x20000b9d
200000d0:	20000bb1 	.word	0x20000bb1
200000d4:	20000bc5 	.word	0x20000bc5
200000d8:	20000bd9 	.word	0x20000bd9
200000dc:	20000bed 	.word	0x20000bed
200000e0:	2000025b 	.word	0x2000025b
200000e4:	2000025d 	.word	0x2000025d
200000e8:	2000025f 	.word	0x2000025f
200000ec:	20000261 	.word	0x20000261
200000f0:	20000263 	.word	0x20000263
200000f4:	20000265 	.word	0x20000265
200000f8:	20000267 	.word	0x20000267
200000fc:	20000269 	.word	0x20000269
20000100:	2000026b 	.word	0x2000026b
20000104:	2000026d 	.word	0x2000026d
20000108:	2000026f 	.word	0x2000026f
2000010c:	20000271 	.word	0x20000271
20000110:	20000273 	.word	0x20000273
20000114:	20000275 	.word	0x20000275
20000118:	20000277 	.word	0x20000277
2000011c:	20000279 	.word	0x20000279
20000120:	2000027b 	.word	0x2000027b
20000124:	2000027d 	.word	0x2000027d
20000128:	2000027f 	.word	0x2000027f
2000012c:	20000281 	.word	0x20000281
20000130:	20000283 	.word	0x20000283
20000134:	20000285 	.word	0x20000285
20000138:	20000287 	.word	0x20000287
2000013c:	20000289 	.word	0x20000289
20000140:	2000028b 	.word	0x2000028b
20000144:	2000028d 	.word	0x2000028d
20000148:	2000028f 	.word	0x2000028f
2000014c:	20000291 	.word	0x20000291
20000150:	20000293 	.word	0x20000293
20000154:	20000295 	.word	0x20000295
20000158:	20000297 	.word	0x20000297
2000015c:	20000299 	.word	0x20000299
20000160:	2000029b 	.word	0x2000029b
20000164:	2000029d 	.word	0x2000029d
20000168:	2000029f 	.word	0x2000029f
2000016c:	200002a1 	.word	0x200002a1
20000170:	200002a3 	.word	0x200002a3
20000174:	200002a5 	.word	0x200002a5
20000178:	200002a7 	.word	0x200002a7
2000017c:	200002a9 	.word	0x200002a9
20000180:	200002ab 	.word	0x200002ab
20000184:	200002ad 	.word	0x200002ad

20000188 <Reset_Handler>:
20000188:	4849      	ldr	r0, [pc, #292]	; (200002b0 <mscc_post_hw_cfg_init+0x2>)
2000018a:	4780      	blx	r0
2000018c:	4849      	ldr	r0, [pc, #292]	; (200002b4 <mscc_post_hw_cfg_init+0x6>)
2000018e:	2800      	cmp	r0, #0
20000190:	d10b      	bne.n	200001aa <copy_data>
20000192:	4849      	ldr	r0, [pc, #292]	; (200002b8 <mscc_post_hw_cfg_init+0xa>)
20000194:	4949      	ldr	r1, [pc, #292]	; (200002bc <mscc_post_hw_cfg_init+0xe>)
20000196:	4a4a      	ldr	r2, [pc, #296]	; (200002c0 <mscc_post_hw_cfg_init+0x12>)
20000198:	4288      	cmp	r0, r1
2000019a:	d006      	beq.n	200001aa <copy_data>

2000019c <copy_code_loop>:
2000019c:	4291      	cmp	r1, r2
2000019e:	bf1c      	itt	ne
200001a0:	f850 3b04 	ldrne.w	r3, [r0], #4
200001a4:	f841 3b04 	strne.w	r3, [r1], #4
200001a8:	d1f8      	bne.n	2000019c <copy_code_loop>

200001aa <copy_data>:
200001aa:	4846      	ldr	r0, [pc, #280]	; (200002c4 <mscc_post_hw_cfg_init+0x16>)
200001ac:	4946      	ldr	r1, [pc, #280]	; (200002c8 <mscc_post_hw_cfg_init+0x1a>)
200001ae:	4a47      	ldr	r2, [pc, #284]	; (200002cc <mscc_post_hw_cfg_init+0x1e>)
200001b0:	4288      	cmp	r0, r1
200001b2:	d006      	beq.n	200001c2 <clear_bss>

200001b4 <copy_data_loop>:
200001b4:	4291      	cmp	r1, r2
200001b6:	bf1c      	itt	ne
200001b8:	f850 3b04 	ldrne.w	r3, [r0], #4
200001bc:	f841 3b04 	strne.w	r3, [r1], #4
200001c0:	d1f8      	bne.n	200001b4 <copy_data_loop>

200001c2 <clear_bss>:
200001c2:	4843      	ldr	r0, [pc, #268]	; (200002d0 <mscc_post_hw_cfg_init+0x22>)
200001c4:	4943      	ldr	r1, [pc, #268]	; (200002d4 <mscc_post_hw_cfg_init+0x26>)
200001c6:	4a44      	ldr	r2, [pc, #272]	; (200002d8 <mscc_post_hw_cfg_init+0x2a>)

200001c8 <clear_bss_loop>:
200001c8:	4291      	cmp	r1, r2
200001ca:	bf18      	it	ne
200001cc:	f841 0b04 	strne.w	r0, [r1], #4
200001d0:	d1fa      	bne.n	200001c8 <clear_bss_loop>
	...

200001e0 <call_glob_ctor>:
200001e0:	f8df 00f8 	ldr.w	r0, [pc, #248]	; 200002dc <mscc_post_hw_cfg_init+0x2e>
200001e4:	f20f 0e03 	addw	lr, pc, #3
200001e8:	4700      	bx	r0

200001ea <branch_to_main>:
200001ea:	f04f 0000 	mov.w	r0, #0
200001ee:	f04f 0100 	mov.w	r1, #0
200001f2:	f8df f0ec 	ldr.w	pc, [pc, #236]	; 200002e0 <mscc_post_hw_cfg_init+0x32>

200001f6 <ExitLoop>:
200001f6:	e7fe      	b.n	200001f6 <ExitLoop>

200001f8 <NMI_Handler>:
200001f8:	e7fe      	b.n	200001f8 <NMI_Handler>

200001fa <HardFault_Handler>:
200001fa:	e7fe      	b.n	200001fa <HardFault_Handler>

200001fc <MemManage_Handler>:
200001fc:	e7fe      	b.n	200001fc <MemManage_Handler>

200001fe <BusFault_Handler>:
200001fe:	e7fe      	b.n	200001fe <BusFault_Handler>

20000200 <UsageFault_Handler>:
20000200:	e7fe      	b.n	20000200 <UsageFault_Handler>
20000202:	e7fe      	b.n	20000202 <UsageFault_Handler+0x2>

20000204 <DebugMon_Handler>:
20000204:	e7fe      	b.n	20000204 <DebugMon_Handler>
20000206:	e7fe      	b.n	20000206 <DebugMon_Handler+0x2>
20000208:	e7fe      	b.n	20000208 <DebugMon_Handler+0x4>

2000020a <WdogWakeup_IRQHandler>:
2000020a:	e7fe      	b.n	2000020a <WdogWakeup_IRQHandler>

2000020c <RTC_Wakeup_IRQHandler>:
2000020c:	e7fe      	b.n	2000020c <RTC_Wakeup_IRQHandler>

2000020e <SPI0_IRQHandler>:
2000020e:	e7fe      	b.n	2000020e <SPI0_IRQHandler>

20000210 <SPI1_IRQHandler>:
20000210:	e7fe      	b.n	20000210 <SPI1_IRQHandler>
20000212:	e7fe      	b.n	20000212 <SPI1_IRQHandler+0x2>

20000214 <I2C0_SMBAlert_IRQHandler>:
20000214:	e7fe      	b.n	20000214 <I2C0_SMBAlert_IRQHandler>

20000216 <I2C0_SMBus_IRQHandler>:
20000216:	e7fe      	b.n	20000216 <I2C0_SMBus_IRQHandler>
20000218:	e7fe      	b.n	20000218 <I2C0_SMBus_IRQHandler+0x2>

2000021a <I2C1_SMBAlert_IRQHandler>:
2000021a:	e7fe      	b.n	2000021a <I2C1_SMBAlert_IRQHandler>

2000021c <I2C1_SMBus_IRQHandler>:
2000021c:	e7fe      	b.n	2000021c <I2C1_SMBus_IRQHandler>
2000021e:	e7fe      	b.n	2000021e <I2C1_SMBus_IRQHandler+0x2>
20000220:	e7fe      	b.n	20000220 <I2C1_SMBus_IRQHandler+0x4>

20000222 <EthernetMAC_IRQHandler>:
20000222:	e7fe      	b.n	20000222 <EthernetMAC_IRQHandler>

20000224 <DMA_IRQHandler>:
20000224:	e7fe      	b.n	20000224 <DMA_IRQHandler>

20000226 <Timer1_IRQHandler>:
20000226:	e7fe      	b.n	20000226 <Timer1_IRQHandler>

20000228 <Timer2_IRQHandler>:
20000228:	e7fe      	b.n	20000228 <Timer2_IRQHandler>

2000022a <CAN_IRQHandler>:
2000022a:	e7fe      	b.n	2000022a <CAN_IRQHandler>

2000022c <ENVM0_IRQHandler>:
2000022c:	e7fe      	b.n	2000022c <ENVM0_IRQHandler>

2000022e <ENVM1_IRQHandler>:
2000022e:	e7fe      	b.n	2000022e <ENVM1_IRQHandler>

20000230 <ComBlk_IRQHandler>:
20000230:	e7fe      	b.n	20000230 <ComBlk_IRQHandler>

20000232 <USB_IRQHandler>:
20000232:	e7fe      	b.n	20000232 <USB_IRQHandler>

20000234 <USB_DMA_IRQHandler>:
20000234:	e7fe      	b.n	20000234 <USB_DMA_IRQHandler>

20000236 <PLL_Lock_IRQHandler>:
20000236:	e7fe      	b.n	20000236 <PLL_Lock_IRQHandler>

20000238 <PLL_LockLost_IRQHandler>:
20000238:	e7fe      	b.n	20000238 <PLL_LockLost_IRQHandler>

2000023a <CommSwitchError_IRQHandler>:
2000023a:	e7fe      	b.n	2000023a <CommSwitchError_IRQHandler>

2000023c <CacheError_IRQHandler>:
2000023c:	e7fe      	b.n	2000023c <CacheError_IRQHandler>

2000023e <DDR_IRQHandler>:
2000023e:	e7fe      	b.n	2000023e <DDR_IRQHandler>

20000240 <HPDMA_Complete_IRQHandler>:
20000240:	e7fe      	b.n	20000240 <HPDMA_Complete_IRQHandler>

20000242 <HPDMA_Error_IRQHandler>:
20000242:	e7fe      	b.n	20000242 <HPDMA_Error_IRQHandler>

20000244 <ECC_Error_IRQHandler>:
20000244:	e7fe      	b.n	20000244 <ECC_Error_IRQHandler>

20000246 <MDDR_IOCalib_IRQHandler>:
20000246:	e7fe      	b.n	20000246 <MDDR_IOCalib_IRQHandler>

20000248 <FAB_PLL_Lock_IRQHandler>:
20000248:	e7fe      	b.n	20000248 <FAB_PLL_Lock_IRQHandler>

2000024a <FAB_PLL_LockLost_IRQHandler>:
2000024a:	e7fe      	b.n	2000024a <FAB_PLL_LockLost_IRQHandler>

2000024c <FIC64_IRQHandler>:
2000024c:	e7fe      	b.n	2000024c <FIC64_IRQHandler>
2000024e:	e7fe      	b.n	2000024e <FIC64_IRQHandler+0x2>
20000250:	e7fe      	b.n	20000250 <FIC64_IRQHandler+0x4>
20000252:	e7fe      	b.n	20000252 <FIC64_IRQHandler+0x6>
20000254:	e7fe      	b.n	20000254 <FIC64_IRQHandler+0x8>
20000256:	e7fe      	b.n	20000256 <FIC64_IRQHandler+0xa>
20000258:	e7fe      	b.n	20000258 <FIC64_IRQHandler+0xc>

2000025a <FabricIrq6_IRQHandler>:
2000025a:	e7fe      	b.n	2000025a <FabricIrq6_IRQHandler>

2000025c <FabricIrq7_IRQHandler>:
2000025c:	e7fe      	b.n	2000025c <FabricIrq7_IRQHandler>

2000025e <FabricIrq8_IRQHandler>:
2000025e:	e7fe      	b.n	2000025e <FabricIrq8_IRQHandler>

20000260 <FabricIrq9_IRQHandler>:
20000260:	e7fe      	b.n	20000260 <FabricIrq9_IRQHandler>

20000262 <FabricIrq10_IRQHandler>:
20000262:	e7fe      	b.n	20000262 <FabricIrq10_IRQHandler>

20000264 <FabricIrq11_IRQHandler>:
20000264:	e7fe      	b.n	20000264 <FabricIrq11_IRQHandler>

20000266 <FabricIrq12_IRQHandler>:
20000266:	e7fe      	b.n	20000266 <FabricIrq12_IRQHandler>

20000268 <FabricIrq13_IRQHandler>:
20000268:	e7fe      	b.n	20000268 <FabricIrq13_IRQHandler>

2000026a <FabricIrq14_IRQHandler>:
2000026a:	e7fe      	b.n	2000026a <FabricIrq14_IRQHandler>

2000026c <FabricIrq15_IRQHandler>:
2000026c:	e7fe      	b.n	2000026c <FabricIrq15_IRQHandler>

2000026e <GPIO0_IRQHandler>:
2000026e:	e7fe      	b.n	2000026e <GPIO0_IRQHandler>

20000270 <GPIO1_IRQHandler>:
20000270:	e7fe      	b.n	20000270 <GPIO1_IRQHandler>

20000272 <GPIO2_IRQHandler>:
20000272:	e7fe      	b.n	20000272 <GPIO2_IRQHandler>

20000274 <GPIO3_IRQHandler>:
20000274:	e7fe      	b.n	20000274 <GPIO3_IRQHandler>

20000276 <GPIO4_IRQHandler>:
20000276:	e7fe      	b.n	20000276 <GPIO4_IRQHandler>

20000278 <GPIO5_IRQHandler>:
20000278:	e7fe      	b.n	20000278 <GPIO5_IRQHandler>

2000027a <GPIO6_IRQHandler>:
2000027a:	e7fe      	b.n	2000027a <GPIO6_IRQHandler>

2000027c <GPIO7_IRQHandler>:
2000027c:	e7fe      	b.n	2000027c <GPIO7_IRQHandler>

2000027e <GPIO8_IRQHandler>:
2000027e:	e7fe      	b.n	2000027e <GPIO8_IRQHandler>

20000280 <GPIO9_IRQHandler>:
20000280:	e7fe      	b.n	20000280 <GPIO9_IRQHandler>

20000282 <GPIO10_IRQHandler>:
20000282:	e7fe      	b.n	20000282 <GPIO10_IRQHandler>

20000284 <GPIO11_IRQHandler>:
20000284:	e7fe      	b.n	20000284 <GPIO11_IRQHandler>

20000286 <GPIO12_IRQHandler>:
20000286:	e7fe      	b.n	20000286 <GPIO12_IRQHandler>

20000288 <GPIO13_IRQHandler>:
20000288:	e7fe      	b.n	20000288 <GPIO13_IRQHandler>

2000028a <GPIO14_IRQHandler>:
2000028a:	e7fe      	b.n	2000028a <GPIO14_IRQHandler>

2000028c <GPIO15_IRQHandler>:
2000028c:	e7fe      	b.n	2000028c <GPIO15_IRQHandler>

2000028e <GPIO16_IRQHandler>:
2000028e:	e7fe      	b.n	2000028e <GPIO16_IRQHandler>

20000290 <GPIO17_IRQHandler>:
20000290:	e7fe      	b.n	20000290 <GPIO17_IRQHandler>

20000292 <GPIO18_IRQHandler>:
20000292:	e7fe      	b.n	20000292 <GPIO18_IRQHandler>

20000294 <GPIO19_IRQHandler>:
20000294:	e7fe      	b.n	20000294 <GPIO19_IRQHandler>

20000296 <GPIO20_IRQHandler>:
20000296:	e7fe      	b.n	20000296 <GPIO20_IRQHandler>

20000298 <GPIO21_IRQHandler>:
20000298:	e7fe      	b.n	20000298 <GPIO21_IRQHandler>

2000029a <GPIO22_IRQHandler>:
2000029a:	e7fe      	b.n	2000029a <GPIO22_IRQHandler>

2000029c <GPIO23_IRQHandler>:
2000029c:	e7fe      	b.n	2000029c <GPIO23_IRQHandler>

2000029e <GPIO24_IRQHandler>:
2000029e:	e7fe      	b.n	2000029e <GPIO24_IRQHandler>

200002a0 <GPIO25_IRQHandler>:
200002a0:	e7fe      	b.n	200002a0 <GPIO25_IRQHandler>

200002a2 <GPIO26_IRQHandler>:
200002a2:	e7fe      	b.n	200002a2 <GPIO26_IRQHandler>

200002a4 <GPIO27_IRQHandler>:
200002a4:	e7fe      	b.n	200002a4 <GPIO27_IRQHandler>

200002a6 <GPIO28_IRQHandler>:
200002a6:	e7fe      	b.n	200002a6 <GPIO28_IRQHandler>

200002a8 <GPIO29_IRQHandler>:
200002a8:	e7fe      	b.n	200002a8 <GPIO29_IRQHandler>

200002aa <GPIO30_IRQHandler>:
200002aa:	e7fe      	b.n	200002aa <GPIO30_IRQHandler>

200002ac <GPIO31_IRQHandler>:
200002ac:	e7fe      	b.n	200002ac <GPIO31_IRQHandler>

200002ae <mscc_post_hw_cfg_init>:
200002ae:	4770      	bx	lr
200002b0:	200027a1 	.word	0x200027a1
200002b4:	00000000 	.word	0x00000000
200002b8:	20000000 	.word	0x20000000
200002bc:	20000000 	.word	0x20000000
200002c0:	20002b10 	.word	0x20002b10
200002c4:	20002b10 	.word	0x20002b10
200002c8:	20002b10 	.word	0x20002b10
200002cc:	20002b18 	.word	0x20002b18
200002d0:	00000000 	.word	0x00000000
200002d4:	20002b18 	.word	0x20002b18
200002d8:	20003428 	.word	0x20003428
200002dc:	200029b1 	.word	0x200029b1
200002e0:	200003c5 	.word	0x200003c5
	...

200002f0 <__do_global_dtors_aux>:
200002f0:	f642 3318 	movw	r3, #11032	; 0x2b18
200002f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200002f8:	781a      	ldrb	r2, [r3, #0]
200002fa:	b90a      	cbnz	r2, 20000300 <__do_global_dtors_aux+0x10>
200002fc:	2001      	movs	r0, #1
200002fe:	7018      	strb	r0, [r3, #0]
20000300:	4770      	bx	lr
20000302:	bf00      	nop

20000304 <frame_dummy>:
20000304:	f642 3010 	movw	r0, #11024	; 0x2b10
20000308:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000030c:	b508      	push	{r3, lr}
2000030e:	6803      	ldr	r3, [r0, #0]
20000310:	b12b      	cbz	r3, 2000031e <frame_dummy+0x1a>
20000312:	f240 0300 	movw	r3, #0
20000316:	f2c0 0300 	movt	r3, #0
2000031a:	b103      	cbz	r3, 2000031e <frame_dummy+0x1a>
2000031c:	4798      	blx	r3
2000031e:	bd08      	pop	{r3, pc}

20000320 <ulGetRunTimeCounterValue>:
	rtsDWT_CONTROL = rtsDWT_CONTROL | rtsCOUNTER_ENABLE_BIT;
}
/*-----------------------------------------------------------*/

uint32_t ulGetRunTimeCounterValue( void )
{
20000320:	b480      	push	{r7}
20000322:	b083      	sub	sp, #12
20000324:	af00      	add	r7, sp, #0
static unsigned long ulLastCounterValue = 0UL, ulOverflows = 0;
unsigned long ulValueNow;

	ulValueNow = rtsDWT_CYCCNT;
20000326:	f241 0304 	movw	r3, #4100	; 0x1004
2000032a:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000032e:	681b      	ldr	r3, [r3, #0]
20000330:	607b      	str	r3, [r7, #4]

	/* Has the value overflowed since it was last read. */
	if( ulValueNow < ulLastCounterValue )
20000332:	f642 331c 	movw	r3, #11036	; 0x2b1c
20000336:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000033a:	681b      	ldr	r3, [r3, #0]
2000033c:	687a      	ldr	r2, [r7, #4]
2000033e:	429a      	cmp	r2, r3
20000340:	d20b      	bcs.n	2000035a <ulGetRunTimeCounterValue+0x3a>
	{
		ulOverflows++;
20000342:	f642 3320 	movw	r3, #11040	; 0x2b20
20000346:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000034a:	681b      	ldr	r3, [r3, #0]
2000034c:	f103 0201 	add.w	r2, r3, #1
20000350:	f642 3320 	movw	r3, #11040	; 0x2b20
20000354:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000358:	601a      	str	r2, [r3, #0]
	}
	ulLastCounterValue = ulValueNow;
2000035a:	f642 331c 	movw	r3, #11036	; 0x2b1c
2000035e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000362:	687a      	ldr	r2, [r7, #4]
20000364:	601a      	str	r2, [r3, #0]

	/* Cannot use configCPU_CLOCK_HZ directly as it may itself not be a constant
	but instead map to a variable that holds the clock speed. */

	/* There is no prescale on the counter, so simulate in software. */
	if( configCPU_CLOCK_HZ < runtimeSLOWER_CLOCK_SPEEDS )
20000366:	f642 3314 	movw	r3, #11028	; 0x2b14
2000036a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000036e:	681a      	ldr	r2, [r3, #0]
20000370:	f641 537f 	movw	r3, #7551	; 0x1d7f
20000374:	f2c0 432c 	movt	r3, #1068	; 0x42c
20000378:	429a      	cmp	r2, r3
2000037a:	d80e      	bhi.n	2000039a <ulGetRunTimeCounterValue+0x7a>
	{
		ulValueNow >>= runtimeSHIFT_13;
2000037c:	687b      	ldr	r3, [r7, #4]
2000037e:	ea4f 3353 	mov.w	r3, r3, lsr #13
20000382:	607b      	str	r3, [r7, #4]
		ulValueNow += ( runtimeOVERFLOW_BIT_13 * ulOverflows );
20000384:	f642 3320 	movw	r3, #11040	; 0x2b20
20000388:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000038c:	681b      	ldr	r3, [r3, #0]
2000038e:	ea4f 43c3 	mov.w	r3, r3, lsl #19
20000392:	687a      	ldr	r2, [r7, #4]
20000394:	4413      	add	r3, r2
20000396:	607b      	str	r3, [r7, #4]
20000398:	e00d      	b.n	200003b6 <ulGetRunTimeCounterValue+0x96>
	}
	else
	{
		ulValueNow >>= runtimeSHIFT_14;
2000039a:	687b      	ldr	r3, [r7, #4]
2000039c:	ea4f 3393 	mov.w	r3, r3, lsr #14
200003a0:	607b      	str	r3, [r7, #4]
		ulValueNow += ( runtimeOVERFLOW_BIT_14 * ulOverflows );
200003a2:	f642 3320 	movw	r3, #11040	; 0x2b20
200003a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200003aa:	681b      	ldr	r3, [r3, #0]
200003ac:	ea4f 4383 	mov.w	r3, r3, lsl #18
200003b0:	687a      	ldr	r2, [r7, #4]
200003b2:	4413      	add	r3, r2
200003b4:	607b      	str	r3, [r7, #4]
	}

	return ulValueNow;
200003b6:	687b      	ldr	r3, [r7, #4]
}
200003b8:	4618      	mov	r0, r3
200003ba:	f107 070c 	add.w	r7, r7, #12
200003be:	46bd      	mov	sp, r7
200003c0:	bc80      	pop	{r7}
200003c2:	4770      	bx	lr

200003c4 <main>:
/* See the documentation page for this demo on the FreeRTOS.org web site for
full information - including hardware setup requirements. */


int main( void )
{
200003c4:	b580      	push	{r7, lr}
200003c6:	b086      	sub	sp, #24
200003c8:	af00      	add	r7, sp, #0
	#if configCREATE_SIMPLE_BLINKY_DEMO_ONLY == 1
	{
		//main_blinky();


		demo();
200003ca:	f000 fad3 	bl	20000974 <demo>
//		uint8_t j = 0;
		//main_full();
	}
	#endif

	return 0;
200003ce:	f04f 0300 	mov.w	r3, #0
}
200003d2:	4618      	mov	r0, r3
200003d4:	f107 0718 	add.w	r7, r7, #24
200003d8:	46bd      	mov	sp, r7
200003da:	bd80      	pop	{r7, pc}

200003dc <vApplicationStackOverflowHook>:
	#endif
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
{
200003dc:	b480      	push	{r7}
200003de:	b085      	sub	sp, #20
200003e0:	af00      	add	r7, sp, #0
200003e2:	6078      	str	r0, [r7, #4]
200003e4:	6039      	str	r1, [r7, #0]

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
200003e6:	f04f 03a0 	mov.w	r3, #160	; 0xa0
200003ea:	f383 8811 	msr	BASEPRI, r3
200003ee:	f3bf 8f6f 	isb	sy
200003f2:	f3bf 8f4f 	dsb	sy
200003f6:	60fb      	str	r3, [r7, #12]

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
	for( ;; );
200003f8:	e7fe      	b.n	200003f8 <vApplicationStackOverflowHook+0x1c>
200003fa:	bf00      	nop

200003fc <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
200003fc:	b480      	push	{r7}
200003fe:	b085      	sub	sp, #20
20000400:	af00      	add	r7, sp, #0
20000402:	6078      	str	r0, [r7, #4]
20000404:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
20000406:	687b      	ldr	r3, [r7, #4]
20000408:	685b      	ldr	r3, [r3, #4]
2000040a:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
2000040c:	683b      	ldr	r3, [r7, #0]
2000040e:	68fa      	ldr	r2, [r7, #12]
20000410:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
20000412:	68fb      	ldr	r3, [r7, #12]
20000414:	689a      	ldr	r2, [r3, #8]
20000416:	683b      	ldr	r3, [r7, #0]
20000418:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
2000041a:	68fb      	ldr	r3, [r7, #12]
2000041c:	689b      	ldr	r3, [r3, #8]
2000041e:	683a      	ldr	r2, [r7, #0]
20000420:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
20000422:	68fb      	ldr	r3, [r7, #12]
20000424:	683a      	ldr	r2, [r7, #0]
20000426:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
20000428:	683b      	ldr	r3, [r7, #0]
2000042a:	687a      	ldr	r2, [r7, #4]
2000042c:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
2000042e:	687b      	ldr	r3, [r7, #4]
20000430:	681b      	ldr	r3, [r3, #0]
20000432:	f103 0201 	add.w	r2, r3, #1
20000436:	687b      	ldr	r3, [r7, #4]
20000438:	601a      	str	r2, [r3, #0]
}
2000043a:	f107 0714 	add.w	r7, r7, #20
2000043e:	46bd      	mov	sp, r7
20000440:	bc80      	pop	{r7}
20000442:	4770      	bx	lr

20000444 <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
20000444:	b480      	push	{r7}
20000446:	b085      	sub	sp, #20
20000448:	af00      	add	r7, sp, #0
2000044a:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
2000044c:	687b      	ldr	r3, [r7, #4]
2000044e:	691b      	ldr	r3, [r3, #16]
20000450:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
20000452:	687b      	ldr	r3, [r7, #4]
20000454:	685b      	ldr	r3, [r3, #4]
20000456:	687a      	ldr	r2, [r7, #4]
20000458:	6892      	ldr	r2, [r2, #8]
2000045a:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
2000045c:	687b      	ldr	r3, [r7, #4]
2000045e:	689b      	ldr	r3, [r3, #8]
20000460:	687a      	ldr	r2, [r7, #4]
20000462:	6852      	ldr	r2, [r2, #4]
20000464:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
20000466:	68fb      	ldr	r3, [r7, #12]
20000468:	685a      	ldr	r2, [r3, #4]
2000046a:	687b      	ldr	r3, [r7, #4]
2000046c:	429a      	cmp	r2, r3
2000046e:	d103      	bne.n	20000478 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
20000470:	687b      	ldr	r3, [r7, #4]
20000472:	689a      	ldr	r2, [r3, #8]
20000474:	68fb      	ldr	r3, [r7, #12]
20000476:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
20000478:	687b      	ldr	r3, [r7, #4]
2000047a:	f04f 0200 	mov.w	r2, #0
2000047e:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
20000480:	68fb      	ldr	r3, [r7, #12]
20000482:	681b      	ldr	r3, [r3, #0]
20000484:	f103 32ff 	add.w	r2, r3, #4294967295
20000488:	68fb      	ldr	r3, [r7, #12]
2000048a:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
2000048c:	68fb      	ldr	r3, [r7, #12]
2000048e:	681b      	ldr	r3, [r3, #0]
}
20000490:	4618      	mov	r0, r3
20000492:	f107 0714 	add.w	r7, r7, #20
20000496:	46bd      	mov	sp, r7
20000498:	bc80      	pop	{r7}
2000049a:	4770      	bx	lr

2000049c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
2000049c:	b580      	push	{r7, lr}
2000049e:	b086      	sub	sp, #24
200004a0:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
200004a2:	f04f 0300 	mov.w	r3, #0
200004a6:	60bb      	str	r3, [r7, #8]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
200004a8:	f642 33ac 	movw	r3, #11180	; 0x2bac
200004ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
200004b0:	681b      	ldr	r3, [r3, #0]
200004b2:	2b00      	cmp	r3, #0
200004b4:	f040 80dc 	bne.w	20000670 <xTaskIncrementTick+0x1d4>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
200004b8:	f642 3394 	movw	r3, #11156	; 0x2b94
200004bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200004c0:	681b      	ldr	r3, [r3, #0]
200004c2:	f103 0301 	add.w	r3, r3, #1
200004c6:	60fb      	str	r3, [r7, #12]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
200004c8:	f642 3394 	movw	r3, #11156	; 0x2b94
200004cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200004d0:	68fa      	ldr	r2, [r7, #12]
200004d2:	601a      	str	r2, [r3, #0]

		if( xConstTickCount == ( TickType_t ) 0U )
200004d4:	68fb      	ldr	r3, [r7, #12]
200004d6:	2b00      	cmp	r3, #0
200004d8:	d135      	bne.n	20000546 <xTaskIncrementTick+0xaa>
		{
			taskSWITCH_DELAYED_LISTS();
200004da:	f642 338c 	movw	r3, #11148	; 0x2b8c
200004de:	f2c2 0300 	movt	r3, #8192	; 0x2000
200004e2:	681b      	ldr	r3, [r3, #0]
200004e4:	681b      	ldr	r3, [r3, #0]
200004e6:	2b00      	cmp	r3, #0
200004e8:	d009      	beq.n	200004fe <xTaskIncrementTick+0x62>
200004ea:	f04f 03a0 	mov.w	r3, #160	; 0xa0
200004ee:	f383 8811 	msr	BASEPRI, r3
200004f2:	f3bf 8f6f 	isb	sy
200004f6:	f3bf 8f4f 	dsb	sy
200004fa:	617b      	str	r3, [r7, #20]
200004fc:	e7fe      	b.n	200004fc <xTaskIncrementTick+0x60>
200004fe:	f642 338c 	movw	r3, #11148	; 0x2b8c
20000502:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000506:	681b      	ldr	r3, [r3, #0]
20000508:	613b      	str	r3, [r7, #16]
2000050a:	f642 3390 	movw	r3, #11152	; 0x2b90
2000050e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000512:	681a      	ldr	r2, [r3, #0]
20000514:	f642 338c 	movw	r3, #11148	; 0x2b8c
20000518:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000051c:	601a      	str	r2, [r3, #0]
2000051e:	f642 3390 	movw	r3, #11152	; 0x2b90
20000522:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000526:	693a      	ldr	r2, [r7, #16]
20000528:	601a      	str	r2, [r3, #0]
2000052a:	f642 33a4 	movw	r3, #11172	; 0x2ba4
2000052e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000532:	681b      	ldr	r3, [r3, #0]
20000534:	f103 0201 	add.w	r2, r3, #1
20000538:	f642 33a4 	movw	r3, #11172	; 0x2ba4
2000053c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000540:	601a      	str	r2, [r3, #0]
20000542:	f000 f987 	bl	20000854 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
20000546:	f642 33a8 	movw	r3, #11176	; 0x2ba8
2000054a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000054e:	681b      	ldr	r3, [r3, #0]
20000550:	68fa      	ldr	r2, [r7, #12]
20000552:	429a      	cmp	r2, r3
20000554:	d373      	bcc.n	2000063e <xTaskIncrementTick+0x1a2>
20000556:	e000      	b.n	2000055a <xTaskIncrementTick+0xbe>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
20000558:	bf00      	nop
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2000055a:	f642 338c 	movw	r3, #11148	; 0x2b8c
2000055e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000562:	681b      	ldr	r3, [r3, #0]
20000564:	681b      	ldr	r3, [r3, #0]
20000566:	2b00      	cmp	r3, #0
20000568:	d102      	bne.n	20000570 <xTaskIncrementTick+0xd4>
2000056a:	f04f 0301 	mov.w	r3, #1
2000056e:	e001      	b.n	20000574 <xTaskIncrementTick+0xd8>
20000570:	f04f 0300 	mov.w	r3, #0
20000574:	2b00      	cmp	r3, #0
20000576:	d007      	beq.n	20000588 <xTaskIncrementTick+0xec>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
20000578:	f642 33a8 	movw	r3, #11176	; 0x2ba8
2000057c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000580:	f04f 32ff 	mov.w	r2, #4294967295
20000584:	601a      	str	r2, [r3, #0]
					break;
20000586:	e05a      	b.n	2000063e <xTaskIncrementTick+0x1a2>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
20000588:	f642 338c 	movw	r3, #11148	; 0x2b8c
2000058c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000590:	681b      	ldr	r3, [r3, #0]
20000592:	68db      	ldr	r3, [r3, #12]
20000594:	68db      	ldr	r3, [r3, #12]
20000596:	603b      	str	r3, [r7, #0]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
20000598:	683b      	ldr	r3, [r7, #0]
2000059a:	685b      	ldr	r3, [r3, #4]
2000059c:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
2000059e:	68fa      	ldr	r2, [r7, #12]
200005a0:	687b      	ldr	r3, [r7, #4]
200005a2:	429a      	cmp	r2, r3
200005a4:	d206      	bcs.n	200005b4 <xTaskIncrementTick+0x118>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
200005a6:	f642 33a8 	movw	r3, #11176	; 0x2ba8
200005aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200005ae:	687a      	ldr	r2, [r7, #4]
200005b0:	601a      	str	r2, [r3, #0]
						break;
200005b2:	e044      	b.n	2000063e <xTaskIncrementTick+0x1a2>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
200005b4:	683b      	ldr	r3, [r7, #0]
200005b6:	f103 0304 	add.w	r3, r3, #4
200005ba:	4618      	mov	r0, r3
200005bc:	f7ff ff42 	bl	20000444 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
200005c0:	683b      	ldr	r3, [r7, #0]
200005c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200005c4:	2b00      	cmp	r3, #0
200005c6:	d005      	beq.n	200005d4 <xTaskIncrementTick+0x138>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
200005c8:	683b      	ldr	r3, [r7, #0]
200005ca:	f103 0318 	add.w	r3, r3, #24
200005ce:	4618      	mov	r0, r3
200005d0:	f7ff ff38 	bl	20000444 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
200005d4:	683b      	ldr	r3, [r7, #0]
200005d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200005d8:	f04f 0201 	mov.w	r2, #1
200005dc:	fa02 f203 	lsl.w	r2, r2, r3
200005e0:	f642 3398 	movw	r3, #11160	; 0x2b98
200005e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200005e8:	681b      	ldr	r3, [r3, #0]
200005ea:	ea42 0203 	orr.w	r2, r2, r3
200005ee:	f642 3398 	movw	r3, #11160	; 0x2b98
200005f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200005f6:	601a      	str	r2, [r3, #0]
200005f8:	683b      	ldr	r3, [r7, #0]
200005fa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
200005fc:	4613      	mov	r3, r2
200005fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
20000602:	4413      	add	r3, r2
20000604:	ea4f 0383 	mov.w	r3, r3, lsl #2
20000608:	461a      	mov	r2, r3
2000060a:	f642 3328 	movw	r3, #11048	; 0x2b28
2000060e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000612:	441a      	add	r2, r3
20000614:	683b      	ldr	r3, [r7, #0]
20000616:	f103 0304 	add.w	r3, r3, #4
2000061a:	4610      	mov	r0, r2
2000061c:	4619      	mov	r1, r3
2000061e:	f7ff feed 	bl	200003fc <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
20000622:	683b      	ldr	r3, [r7, #0]
20000624:	6ada      	ldr	r2, [r3, #44]	; 0x2c
20000626:	f642 3324 	movw	r3, #11044	; 0x2b24
2000062a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000062e:	681b      	ldr	r3, [r3, #0]
20000630:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20000632:	429a      	cmp	r2, r3
20000634:	d390      	bcc.n	20000558 <xTaskIncrementTick+0xbc>
						{
							xSwitchRequired = pdTRUE;
20000636:	f04f 0301 	mov.w	r3, #1
2000063a:	60bb      	str	r3, [r7, #8]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
2000063c:	e78d      	b.n	2000055a <xTaskIncrementTick+0xbe>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
2000063e:	f642 3324 	movw	r3, #11044	; 0x2b24
20000642:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000646:	681b      	ldr	r3, [r3, #0]
20000648:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2000064a:	4613      	mov	r3, r2
2000064c:	ea4f 0383 	mov.w	r3, r3, lsl #2
20000650:	4413      	add	r3, r2
20000652:	ea4f 0383 	mov.w	r3, r3, lsl #2
20000656:	461a      	mov	r2, r3
20000658:	f642 3328 	movw	r3, #11048	; 0x2b28
2000065c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000660:	4413      	add	r3, r2
20000662:	681b      	ldr	r3, [r3, #0]
20000664:	2b01      	cmp	r3, #1
20000666:	d910      	bls.n	2000068a <xTaskIncrementTick+0x1ee>
			{
				xSwitchRequired = pdTRUE;
20000668:	f04f 0301 	mov.w	r3, #1
2000066c:	60bb      	str	r3, [r7, #8]
2000066e:	e00d      	b.n	2000068c <xTaskIncrementTick+0x1f0>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
20000670:	f642 339c 	movw	r3, #11164	; 0x2b9c
20000674:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000678:	681b      	ldr	r3, [r3, #0]
2000067a:	f103 0201 	add.w	r2, r3, #1
2000067e:	f642 339c 	movw	r3, #11164	; 0x2b9c
20000682:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000686:	601a      	str	r2, [r3, #0]
20000688:	e000      	b.n	2000068c <xTaskIncrementTick+0x1f0>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
2000068a:	bf00      	nop
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
2000068c:	f642 33a0 	movw	r3, #11168	; 0x2ba0
20000690:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000694:	681b      	ldr	r3, [r3, #0]
20000696:	2b00      	cmp	r3, #0
20000698:	d002      	beq.n	200006a0 <xTaskIncrementTick+0x204>
		{
			xSwitchRequired = pdTRUE;
2000069a:	f04f 0301 	mov.w	r3, #1
2000069e:	60bb      	str	r3, [r7, #8]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
200006a0:	68bb      	ldr	r3, [r7, #8]
}
200006a2:	4618      	mov	r0, r3
200006a4:	f107 0718 	add.w	r7, r7, #24
200006a8:	46bd      	mov	sp, r7
200006aa:	bd80      	pop	{r7, pc}

200006ac <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
200006ac:	b580      	push	{r7, lr}
200006ae:	b088      	sub	sp, #32
200006b0:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
200006b2:	f642 33ac 	movw	r3, #11180	; 0x2bac
200006b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006ba:	681b      	ldr	r3, [r3, #0]
200006bc:	2b00      	cmp	r3, #0
200006be:	d007      	beq.n	200006d0 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
200006c0:	f642 33a0 	movw	r3, #11168	; 0x2ba0
200006c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006c8:	f04f 0201 	mov.w	r2, #1
200006cc:	601a      	str	r2, [r3, #0]
200006ce:	e0bc      	b.n	2000084a <vTaskSwitchContext+0x19e>
	}
	else
	{
		xYieldPending = pdFALSE;
200006d0:	f642 33a0 	movw	r3, #11168	; 0x2ba0
200006d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006d8:	f04f 0200 	mov.w	r2, #0
200006dc:	601a      	str	r2, [r3, #0]
		#if ( configGENERATE_RUN_TIME_STATS == 1 )
		{
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
				#else
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
200006de:	f7ff fe1f 	bl	20000320 <ulGetRunTimeCounterValue>
200006e2:	4602      	mov	r2, r0
200006e4:	f642 33b4 	movw	r3, #11188	; 0x2bb4
200006e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006ec:	601a      	str	r2, [r3, #0]
				stored in ulTaskSwitchedInTime.  Note that there is no overflow
				protection here so count values are only valid until the timer
				overflows.  The guard against negative values is to protect
				against suspect run time stat counter implementations - which
				are provided by the application, not the kernel. */
				if( ulTotalRunTime > ulTaskSwitchedInTime )
200006ee:	f642 33b4 	movw	r3, #11188	; 0x2bb4
200006f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006f6:	681a      	ldr	r2, [r3, #0]
200006f8:	f642 33b0 	movw	r3, #11184	; 0x2bb0
200006fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000700:	681b      	ldr	r3, [r3, #0]
20000702:	429a      	cmp	r2, r3
20000704:	d913      	bls.n	2000072e <vTaskSwitchContext+0x82>
				{
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
20000706:	f642 3324 	movw	r3, #11044	; 0x2b24
2000070a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000070e:	681a      	ldr	r2, [r3, #0]
20000710:	6d11      	ldr	r1, [r2, #80]	; 0x50
20000712:	f642 33b4 	movw	r3, #11188	; 0x2bb4
20000716:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000071a:	6818      	ldr	r0, [r3, #0]
2000071c:	f642 33b0 	movw	r3, #11184	; 0x2bb0
20000720:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000724:	681b      	ldr	r3, [r3, #0]
20000726:	ebc3 0300 	rsb	r3, r3, r0
2000072a:	440b      	add	r3, r1
2000072c:	6513      	str	r3, [r2, #80]	; 0x50
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				ulTaskSwitchedInTime = ulTotalRunTime;
2000072e:	f642 33b4 	movw	r3, #11188	; 0x2bb4
20000732:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000736:	681a      	ldr	r2, [r3, #0]
20000738:	f642 33b0 	movw	r3, #11184	; 0x2bb0
2000073c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000740:	601a      	str	r2, [r3, #0]
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
20000742:	f642 3324 	movw	r3, #11044	; 0x2b24
20000746:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000074a:	681b      	ldr	r3, [r3, #0]
2000074c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000074e:	607b      	str	r3, [r7, #4]
20000750:	f04f 33a5 	mov.w	r3, #2779096485	; 0xa5a5a5a5
20000754:	60bb      	str	r3, [r7, #8]
20000756:	687b      	ldr	r3, [r7, #4]
20000758:	681a      	ldr	r2, [r3, #0]
2000075a:	68bb      	ldr	r3, [r7, #8]
2000075c:	429a      	cmp	r2, r3
2000075e:	d114      	bne.n	2000078a <vTaskSwitchContext+0xde>
20000760:	687b      	ldr	r3, [r7, #4]
20000762:	f103 0304 	add.w	r3, r3, #4
20000766:	681a      	ldr	r2, [r3, #0]
20000768:	68bb      	ldr	r3, [r7, #8]
2000076a:	429a      	cmp	r2, r3
2000076c:	d10d      	bne.n	2000078a <vTaskSwitchContext+0xde>
2000076e:	687b      	ldr	r3, [r7, #4]
20000770:	f103 0308 	add.w	r3, r3, #8
20000774:	681a      	ldr	r2, [r3, #0]
20000776:	68bb      	ldr	r3, [r7, #8]
20000778:	429a      	cmp	r2, r3
2000077a:	d106      	bne.n	2000078a <vTaskSwitchContext+0xde>
2000077c:	687b      	ldr	r3, [r7, #4]
2000077e:	f103 030c 	add.w	r3, r3, #12
20000782:	681a      	ldr	r2, [r3, #0]
20000784:	68bb      	ldr	r3, [r7, #8]
20000786:	429a      	cmp	r2, r3
20000788:	d00f      	beq.n	200007aa <vTaskSwitchContext+0xfe>
2000078a:	f642 3324 	movw	r3, #11044	; 0x2b24
2000078e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000792:	681a      	ldr	r2, [r3, #0]
20000794:	f642 3324 	movw	r3, #11044	; 0x2b24
20000798:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000079c:	681b      	ldr	r3, [r3, #0]
2000079e:	f103 0334 	add.w	r3, r3, #52	; 0x34
200007a2:	4610      	mov	r0, r2
200007a4:	4619      	mov	r1, r3
200007a6:	f7ff fe19 	bl	200003dc <vApplicationStackOverflowHook>

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
200007aa:	f642 3398 	movw	r3, #11160	; 0x2b98
200007ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
200007b2:	681b      	ldr	r3, [r3, #0]
200007b4:	617b      	str	r3, [r7, #20]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
200007b6:	697b      	ldr	r3, [r7, #20]
200007b8:	fab3 f383 	clz	r3, r3
200007bc:	76fb      	strb	r3, [r7, #27]
		return ucReturn;
200007be:	7efb      	ldrb	r3, [r7, #27]
200007c0:	f1c3 031f 	rsb	r3, r3, #31
200007c4:	60fb      	str	r3, [r7, #12]
200007c6:	68fa      	ldr	r2, [r7, #12]
200007c8:	4613      	mov	r3, r2
200007ca:	ea4f 0383 	mov.w	r3, r3, lsl #2
200007ce:	4413      	add	r3, r2
200007d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
200007d4:	461a      	mov	r2, r3
200007d6:	f642 3328 	movw	r3, #11048	; 0x2b28
200007da:	f2c2 0300 	movt	r3, #8192	; 0x2000
200007de:	4413      	add	r3, r2
200007e0:	681b      	ldr	r3, [r3, #0]
200007e2:	2b00      	cmp	r3, #0
200007e4:	d109      	bne.n	200007fa <vTaskSwitchContext+0x14e>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
200007e6:	f04f 03a0 	mov.w	r3, #160	; 0xa0
200007ea:	f383 8811 	msr	BASEPRI, r3
200007ee:	f3bf 8f6f 	isb	sy
200007f2:	f3bf 8f4f 	dsb	sy
200007f6:	61fb      	str	r3, [r7, #28]
200007f8:	e7fe      	b.n	200007f8 <vTaskSwitchContext+0x14c>
200007fa:	68fa      	ldr	r2, [r7, #12]
200007fc:	4613      	mov	r3, r2
200007fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
20000802:	4413      	add	r3, r2
20000804:	ea4f 0383 	mov.w	r3, r3, lsl #2
20000808:	461a      	mov	r2, r3
2000080a:	f642 3328 	movw	r3, #11048	; 0x2b28
2000080e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000812:	4413      	add	r3, r2
20000814:	613b      	str	r3, [r7, #16]
20000816:	693b      	ldr	r3, [r7, #16]
20000818:	685b      	ldr	r3, [r3, #4]
2000081a:	685a      	ldr	r2, [r3, #4]
2000081c:	693b      	ldr	r3, [r7, #16]
2000081e:	605a      	str	r2, [r3, #4]
20000820:	693b      	ldr	r3, [r7, #16]
20000822:	685a      	ldr	r2, [r3, #4]
20000824:	693b      	ldr	r3, [r7, #16]
20000826:	f103 0308 	add.w	r3, r3, #8
2000082a:	429a      	cmp	r2, r3
2000082c:	d104      	bne.n	20000838 <vTaskSwitchContext+0x18c>
2000082e:	693b      	ldr	r3, [r7, #16]
20000830:	685b      	ldr	r3, [r3, #4]
20000832:	685a      	ldr	r2, [r3, #4]
20000834:	693b      	ldr	r3, [r7, #16]
20000836:	605a      	str	r2, [r3, #4]
20000838:	693b      	ldr	r3, [r7, #16]
2000083a:	685b      	ldr	r3, [r3, #4]
2000083c:	68db      	ldr	r3, [r3, #12]
2000083e:	461a      	mov	r2, r3
20000840:	f642 3324 	movw	r3, #11044	; 0x2b24
20000844:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000848:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
2000084a:	f107 0720 	add.w	r7, r7, #32
2000084e:	46bd      	mov	sp, r7
20000850:	bd80      	pop	{r7, pc}
20000852:	bf00      	nop

20000854 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
20000854:	b480      	push	{r7}
20000856:	b083      	sub	sp, #12
20000858:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2000085a:	f642 338c 	movw	r3, #11148	; 0x2b8c
2000085e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000862:	681b      	ldr	r3, [r3, #0]
20000864:	681b      	ldr	r3, [r3, #0]
20000866:	2b00      	cmp	r3, #0
20000868:	d102      	bne.n	20000870 <prvResetNextTaskUnblockTime+0x1c>
2000086a:	f04f 0301 	mov.w	r3, #1
2000086e:	e001      	b.n	20000874 <prvResetNextTaskUnblockTime+0x20>
20000870:	f04f 0300 	mov.w	r3, #0
20000874:	2b00      	cmp	r3, #0
20000876:	d007      	beq.n	20000888 <prvResetNextTaskUnblockTime+0x34>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
20000878:	f642 33a8 	movw	r3, #11176	; 0x2ba8
2000087c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000880:	f04f 32ff 	mov.w	r2, #4294967295
20000884:	601a      	str	r2, [r3, #0]
20000886:	e00e      	b.n	200008a6 <prvResetNextTaskUnblockTime+0x52>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
20000888:	f642 338c 	movw	r3, #11148	; 0x2b8c
2000088c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000890:	681b      	ldr	r3, [r3, #0]
20000892:	68db      	ldr	r3, [r3, #12]
20000894:	68db      	ldr	r3, [r3, #12]
20000896:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
20000898:	687b      	ldr	r3, [r7, #4]
2000089a:	685a      	ldr	r2, [r3, #4]
2000089c:	f642 33a8 	movw	r3, #11176	; 0x2ba8
200008a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008a4:	601a      	str	r2, [r3, #0]
	}
}
200008a6:	f107 070c 	add.w	r7, r7, #12
200008aa:	46bd      	mov	sp, r7
200008ac:	bc80      	pop	{r7}
200008ae:	4770      	bx	lr

200008b0 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
200008b0:	4b07      	ldr	r3, [pc, #28]	; (200008d0 <pxCurrentTCBConst2>)
200008b2:	6819      	ldr	r1, [r3, #0]
200008b4:	6808      	ldr	r0, [r1, #0]
200008b6:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
200008ba:	f380 8809 	msr	PSP, r0
200008be:	f3bf 8f6f 	isb	sy
200008c2:	f04f 0000 	mov.w	r0, #0
200008c6:	f380 8811 	msr	BASEPRI, r0
200008ca:	f04e 0e0d 	orr.w	lr, lr, #13
200008ce:	4770      	bx	lr

200008d0 <pxCurrentTCBConst2>:
200008d0:	20002b24 	.word	0x20002b24
200008d4:	f3af 8000 	nop.w
200008d8:	f3af 8000 	nop.w
200008dc:	f3af 8000 	nop.w

200008e0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
200008e0:	f3ef 8009 	mrs	r0, PSP
200008e4:	f3bf 8f6f 	isb	sy
200008e8:	4b0d      	ldr	r3, [pc, #52]	; (20000920 <pxCurrentTCBConst>)
200008ea:	681a      	ldr	r2, [r3, #0]
200008ec:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
200008f0:	6010      	str	r0, [r2, #0]
200008f2:	e92d 4008 	stmdb	sp!, {r3, lr}
200008f6:	f04f 00a0 	mov.w	r0, #160	; 0xa0
200008fa:	f380 8811 	msr	BASEPRI, r0
200008fe:	f7ff fed5 	bl	200006ac <vTaskSwitchContext>
20000902:	f04f 0000 	mov.w	r0, #0
20000906:	f380 8811 	msr	BASEPRI, r0
2000090a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
2000090e:	6819      	ldr	r1, [r3, #0]
20000910:	6808      	ldr	r0, [r1, #0]
20000912:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
20000916:	f380 8809 	msr	PSP, r0
2000091a:	f3bf 8f6f 	isb	sy
2000091e:	4770      	bx	lr

20000920 <pxCurrentTCBConst>:
20000920:	20002b24 	.word	0x20002b24
20000924:	f3af 8000 	nop.w
20000928:	f3af 8000 	nop.w
2000092c:	f3af 8000 	nop.w

20000930 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
20000930:	b580      	push	{r7, lr}
20000932:	b082      	sub	sp, #8
20000934:	af00      	add	r7, sp, #0
20000936:	f04f 03a0 	mov.w	r3, #160	; 0xa0
2000093a:	f383 8811 	msr	BASEPRI, r3
2000093e:	f3bf 8f6f 	isb	sy
20000942:	f3bf 8f4f 	dsb	sy
20000946:	603b      	str	r3, [r7, #0]
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
20000948:	f7ff fda8 	bl	2000049c <xTaskIncrementTick>
2000094c:	4603      	mov	r3, r0
2000094e:	2b00      	cmp	r3, #0
20000950:	d006      	beq.n	20000960 <SysTick_Handler+0x30>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
20000952:	f64e 5304 	movw	r3, #60676	; 0xed04
20000956:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000095a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
2000095e:	601a      	str	r2, [r3, #0]
20000960:	f04f 0300 	mov.w	r3, #0
20000964:	607b      	str	r3, [r7, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
20000966:	687b      	ldr	r3, [r7, #4]
20000968:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
2000096c:	f107 0708 	add.w	r7, r7, #8
20000970:	46bd      	mov	sp, r7
20000972:	bd80      	pop	{r7, pc}

20000974 <demo>:
//	 }
//}



void demo(void){
20000974:	b580      	push	{r7, lr}
20000976:	b08e      	sub	sp, #56	; 0x38
20000978:	af02      	add	r7, sp, #8
//		 uint8_t msg[1]  ;
//		 msg[0] = 3;


//		imu_t* imu_struct = (imu_t*) device_param;
		uint8_t REF_DATA[3] = {0x38, 0x00, 0x05};
2000097a:	f642 22d4 	movw	r2, #10964	; 0x2ad4
2000097e:	f2c2 0200 	movt	r2, #8192	; 0x2000
20000982:	f107 0328 	add.w	r3, r7, #40	; 0x28
20000986:	6812      	ldr	r2, [r2, #0]
20000988:	4611      	mov	r1, r2
2000098a:	8019      	strh	r1, [r3, #0]
2000098c:	f103 0302 	add.w	r3, r3, #2
20000990:	ea4f 4212 	mov.w	r2, r2, lsr #16
20000994:	701a      	strb	r2, [r3, #0]
		uint8_t PWR[3] = {0x20, 0x00, 0x3F};
20000996:	f642 22d8 	movw	r2, #10968	; 0x2ad8
2000099a:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000099e:	f107 0324 	add.w	r3, r7, #36	; 0x24
200009a2:	6812      	ldr	r2, [r2, #0]
200009a4:	4611      	mov	r1, r2
200009a6:	8019      	strh	r1, [r3, #0]
200009a8:	f103 0302 	add.w	r3, r3, #2
200009ac:	ea4f 4212 	mov.w	r2, r2, lsr #16
200009b0:	701a      	strb	r2, [r3, #0]
		uint8_t config[3] = {0x30, 0x00, 0x0F};
200009b2:	f642 22dc 	movw	r2, #10972	; 0x2adc
200009b6:	f2c2 0200 	movt	r2, #8192	; 0x2000
200009ba:	f107 0320 	add.w	r3, r7, #32
200009be:	6812      	ldr	r2, [r2, #0]
200009c0:	4611      	mov	r1, r2
200009c2:	8019      	strh	r1, [r3, #0]
200009c4:	f103 0302 	add.w	r3, r3, #2
200009c8:	ea4f 4212 	mov.w	r2, r2, lsr #16
200009cc:	701a      	strb	r2, [r3, #0]
		uint8_t sw_clear[3] = {0x28, 0x00, 0x00};
200009ce:	f04f 0328 	mov.w	r3, #40	; 0x28
200009d2:	773b      	strb	r3, [r7, #28]
200009d4:	f04f 0300 	mov.w	r3, #0
200009d8:	777b      	strb	r3, [r7, #29]
200009da:	f04f 0300 	mov.w	r3, #0
200009de:	77bb      	strb	r3, [r7, #30]
		uint8_t sw_reset[3] = {0x28, 0x00, 0x01};
200009e0:	f642 22e0 	movw	r2, #10976	; 0x2ae0
200009e4:	f2c2 0200 	movt	r2, #8192	; 0x2000
200009e8:	f107 0318 	add.w	r3, r7, #24
200009ec:	6812      	ldr	r2, [r2, #0]
200009ee:	4611      	mov	r1, r2
200009f0:	8019      	strh	r1, [r3, #0]
200009f2:	f103 0302 	add.w	r3, r3, #2
200009f6:	ea4f 4212 	mov.w	r2, r2, lsr #16
200009fa:	701a      	strb	r2, [r3, #0]
//		static vc_sensor_t vc_struct = {VC1, &g_core_i2c3, COREI2C_3_0, I2C_PCLK_DIV_256, {0,0}, {0,0}, {0,0}};
//		vc_dev = &vc_struct;
//		vc_ptr->init = &init;
//		vc_ptr->init(vc_sensor, (void* )vc_dev);

		I2C_init(&g_core_i2c3, COREI2C_3_0, DAC_ADDR, I2C_PCLK_DIV_256);
200009fc:	f243 10e0 	movw	r0, #12768	; 0x31e0
20000a00:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000a04:	f243 0100 	movw	r1, #12288	; 0x3000
20000a08:	f2c5 0100 	movt	r1, #20480	; 0x5000
20000a0c:	f04f 020e 	mov.w	r2, #14
20000a10:	f04f 0300 	mov.w	r3, #0
20000a14:	f000 ff1e 	bl	20001854 <I2C_init>


//		pkt_timer[1] = xTimerCreate("PLD_Timer", pdMS_TO_TICKS(3000), pdTRUE, (void*)0, vpld_callback);
//		xTimerStart(pkt_timer[1],0);

		I2C_write(VC_SENSOR_I2C, DAC_ADDR, sw_clear, 3, I2C_RELEASE_BUS);
20000a18:	f107 031c 	add.w	r3, r7, #28
20000a1c:	f04f 0200 	mov.w	r2, #0
20000a20:	9200      	str	r2, [sp, #0]
20000a22:	f243 10e0 	movw	r0, #12768	; 0x31e0
20000a26:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000a2a:	f04f 010e 	mov.w	r1, #14
20000a2e:	461a      	mov	r2, r3
20000a30:	f04f 0303 	mov.w	r3, #3
20000a34:	f000 ff84 	bl	20001940 <I2C_write>
		status = I2C_wait_complete(VC_SENSOR_I2C, I2C_NO_TIMEOUT);
20000a38:	f243 10e0 	movw	r0, #12768	; 0x31e0
20000a3c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000a40:	f04f 0100 	mov.w	r1, #0
20000a44:	f001 f860 	bl	20001b08 <I2C_wait_complete>
20000a48:	4603      	mov	r3, r0
20000a4a:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

		I2C_write(VC_SENSOR_I2C, DAC_ADDR, sw_reset, 3, I2C_RELEASE_BUS);
20000a4e:	f107 0318 	add.w	r3, r7, #24
20000a52:	f04f 0200 	mov.w	r2, #0
20000a56:	9200      	str	r2, [sp, #0]
20000a58:	f243 10e0 	movw	r0, #12768	; 0x31e0
20000a5c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000a60:	f04f 010e 	mov.w	r1, #14
20000a64:	461a      	mov	r2, r3
20000a66:	f04f 0303 	mov.w	r3, #3
20000a6a:	f000 ff69 	bl	20001940 <I2C_write>
		status = I2C_wait_complete(VC_SENSOR_I2C, I2C_NO_TIMEOUT);
20000a6e:	f243 10e0 	movw	r0, #12768	; 0x31e0
20000a72:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000a76:	f04f 0100 	mov.w	r1, #0
20000a7a:	f001 f845 	bl	20001b08 <I2C_wait_complete>
20000a7e:	4603      	mov	r3, r0
20000a80:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

		I2C_write(VC_SENSOR_I2C, DAC_ADDR, REF_DATA, 3, I2C_RELEASE_BUS);
20000a84:	f107 0328 	add.w	r3, r7, #40	; 0x28
20000a88:	f04f 0200 	mov.w	r2, #0
20000a8c:	9200      	str	r2, [sp, #0]
20000a8e:	f243 10e0 	movw	r0, #12768	; 0x31e0
20000a92:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000a96:	f04f 010e 	mov.w	r1, #14
20000a9a:	461a      	mov	r2, r3
20000a9c:	f04f 0303 	mov.w	r3, #3
20000aa0:	f000 ff4e 	bl	20001940 <I2C_write>
		status = I2C_wait_complete(VC_SENSOR_I2C, I2C_NO_TIMEOUT);
20000aa4:	f243 10e0 	movw	r0, #12768	; 0x31e0
20000aa8:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000aac:	f04f 0100 	mov.w	r1, #0
20000ab0:	f001 f82a 	bl	20001b08 <I2C_wait_complete>
20000ab4:	4603      	mov	r3, r0
20000ab6:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
//		status = I2C_wait_complete(VC_SENSOR_I2C, I2C_NO_TIMEOUT);

//		MSS_UART_init(&g_mss_uart0, 9600, MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT);
//		MSS_UART_set_rx_handler(&g_mss_uart0, uart0_rx_handler, MSS_UART_ONE_STOP_BIT);

		uint8_t DAC_rdb[3] = {0x18, 0x11, 0x00};
20000aba:	f642 22e4 	movw	r2, #10980	; 0x2ae4
20000abe:	f2c2 0200 	movt	r2, #8192	; 0x2000
20000ac2:	f107 0314 	add.w	r3, r7, #20
20000ac6:	6812      	ldr	r2, [r2, #0]
20000ac8:	4611      	mov	r1, r2
20000aca:	8019      	strh	r1, [r3, #0]
20000acc:	f103 0302 	add.w	r3, r3, #2
20000ad0:	ea4f 4212 	mov.w	r2, r2, lsr #16
20000ad4:	701a      	strb	r2, [r3, #0]
		uint8_t DAC_A_cmd_clall[3] = {0x10, 0xFF, 0xF0};
20000ad6:	f642 22e8 	movw	r2, #10984	; 0x2ae8
20000ada:	f2c2 0200 	movt	r2, #8192	; 0x2000
20000ade:	f107 0310 	add.w	r3, r7, #16
20000ae2:	6812      	ldr	r2, [r2, #0]
20000ae4:	4611      	mov	r1, r2
20000ae6:	8019      	strh	r1, [r3, #0]
20000ae8:	f103 0302 	add.w	r3, r3, #2
20000aec:	ea4f 4212 	mov.w	r2, r2, lsr #16
20000af0:	701a      	strb	r2, [r3, #0]
		uint8_t Code_rdb[1] = {0x00};
20000af2:	f04f 0300 	mov.w	r3, #0
20000af6:	733b      	strb	r3, [r7, #12]
		uint8_t Load_rdb[1] = {0x08};
20000af8:	f04f 0308 	mov.w	r3, #8
20000afc:	723b      	strb	r3, [r7, #8]
		uint8_t DAC_A_cmd_cln[3] = {0x18, 0xEE, 0xE0};
20000afe:	f642 22ec 	movw	r2, #10988	; 0x2aec
20000b02:	f2c2 0200 	movt	r2, #8192	; 0x2000
20000b06:	f107 0304 	add.w	r3, r7, #4
20000b0a:	6812      	ldr	r2, [r2, #0]
20000b0c:	4611      	mov	r1, r2
20000b0e:	8019      	strh	r1, [r3, #0]
20000b10:	f103 0302 	add.w	r3, r3, #2
20000b14:	ea4f 4212 	mov.w	r2, r2, lsr #16
20000b18:	701a      	strb	r2, [r3, #0]


//			for(j=0;j<50;j++){
//
//			}
			I2C_write(VC_SENSOR_I2C, DAC_ADDR, DAC_rdb, 3, I2C_RELEASE_BUS);
20000b1a:	f107 0314 	add.w	r3, r7, #20
20000b1e:	f04f 0200 	mov.w	r2, #0
20000b22:	9200      	str	r2, [sp, #0]
20000b24:	f243 10e0 	movw	r0, #12768	; 0x31e0
20000b28:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000b2c:	f04f 010e 	mov.w	r1, #14
20000b30:	461a      	mov	r2, r3
20000b32:	f04f 0303 	mov.w	r3, #3
20000b36:	f000 ff03 	bl	20001940 <I2C_write>
			status = I2C_wait_complete(VC_SENSOR_I2C, I2C_NO_TIMEOUT);
20000b3a:	f243 10e0 	movw	r0, #12768	; 0x31e0
20000b3e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000b42:	f04f 0100 	mov.w	r1, #0
20000b46:	f000 ffdf 	bl	20001b08 <I2C_wait_complete>
20000b4a:	4603      	mov	r3, r0
20000b4c:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
			I2C_read(VC_SENSOR_I2C, DAC_ADDR, rdb_buf, 3, I2C_RELEASE_BUS);
20000b50:	463b      	mov	r3, r7
20000b52:	f04f 0200 	mov.w	r2, #0
20000b56:	9200      	str	r2, [sp, #0]
20000b58:	f243 10e0 	movw	r0, #12768	; 0x31e0
20000b5c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000b60:	f04f 010e 	mov.w	r1, #14
20000b64:	461a      	mov	r2, r3
20000b66:	f04f 0303 	mov.w	r3, #3
20000b6a:	f000 ff5b 	bl	20001a24 <I2C_read>
			status = I2C_wait_complete(VC_SENSOR_I2C, I2C_NO_TIMEOUT);
20000b6e:	f243 10e0 	movw	r0, #12768	; 0x31e0
20000b72:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000b76:	f04f 0100 	mov.w	r1, #0
20000b7a:	f000 ffc5 	bl	20001b08 <I2C_wait_complete>
20000b7e:	4603      	mov	r3, r0
20000b80:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

		}
20000b84:	e7c9      	b.n	20000b1a <demo+0x1a6>
20000b86:	bf00      	nop

20000b88 <FabricIrq0_IRQHandler>:
//	vTaskStartScheduler();

}

void FabricIrq0_IRQHandler(void)
{
20000b88:	b580      	push	{r7, lr}
20000b8a:	af00      	add	r7, sp, #0
    I2C_isr(&g_core_i2c0);
20000b8c:	f243 009c 	movw	r0, #12444	; 0x309c
20000b90:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000b94:	f000 ffec 	bl	20001b70 <I2C_isr>
}
20000b98:	bd80      	pop	{r7, pc}
20000b9a:	bf00      	nop

20000b9c <FabricIrq1_IRQHandler>:

void FabricIrq1_IRQHandler(void)
{
20000b9c:	b580      	push	{r7, lr}
20000b9e:	af00      	add	r7, sp, #0
    I2C_isr(&g_core_i2c1);
20000ba0:	f243 1008 	movw	r0, #12552	; 0x3108
20000ba4:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000ba8:	f000 ffe2 	bl	20001b70 <I2C_isr>
}
20000bac:	bd80      	pop	{r7, pc}
20000bae:	bf00      	nop

20000bb0 <FabricIrq2_IRQHandler>:

void FabricIrq2_IRQHandler(void)
{
20000bb0:	b580      	push	{r7, lr}
20000bb2:	af00      	add	r7, sp, #0
    I2C_isr(&g_core_i2c2);
20000bb4:	f642 30ec 	movw	r0, #11244	; 0x2bec
20000bb8:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000bbc:	f000 ffd8 	bl	20001b70 <I2C_isr>
}
20000bc0:	bd80      	pop	{r7, pc}
20000bc2:	bf00      	nop

20000bc4 <FabricIrq3_IRQHandler>:

void FabricIrq3_IRQHandler(void)
{
20000bc4:	b580      	push	{r7, lr}
20000bc6:	af00      	add	r7, sp, #0
    I2C_isr(&g_core_i2c3);
20000bc8:	f243 10e0 	movw	r0, #12768	; 0x31e0
20000bcc:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000bd0:	f000 ffce 	bl	20001b70 <I2C_isr>
}
20000bd4:	bd80      	pop	{r7, pc}
20000bd6:	bf00      	nop

20000bd8 <FabricIrq4_IRQHandler>:

void FabricIrq4_IRQHandler(void)
{
20000bd8:	b580      	push	{r7, lr}
20000bda:	af00      	add	r7, sp, #0
    I2C_isr(&g_core_i2c4);
20000bdc:	f243 2054 	movw	r0, #12884	; 0x3254
20000be0:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000be4:	f000 ffc4 	bl	20001b70 <I2C_isr>
}
20000be8:	bd80      	pop	{r7, pc}
20000bea:	bf00      	nop

20000bec <FabricIrq5_IRQHandler>:

void FabricIrq5_IRQHandler(void)
{
20000bec:	b580      	push	{r7, lr}
20000bee:	af00      	add	r7, sp, #0
    I2C_isr(&g_core_i2c5);
20000bf0:	f243 1074 	movw	r0, #12660	; 0x3174
20000bf4:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000bf8:	f000 ffba 	bl	20001b70 <I2C_isr>
}
20000bfc:	bd80      	pop	{r7, pc}
20000bfe:	bf00      	nop

20000c00 <read_bit_reg8>:
static __INLINE uint8_t read_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    return (HW_REG_BIT(reg,bit));
}
static __INLINE uint8_t read_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
20000c00:	b480      	push	{r7}
20000c02:	b083      	sub	sp, #12
20000c04:	af00      	add	r7, sp, #0
20000c06:	6078      	str	r0, [r7, #4]
20000c08:	460b      	mov	r3, r1
20000c0a:	70fb      	strb	r3, [r7, #3]
    return (HW_REG_BIT(reg,bit));
20000c0c:	687b      	ldr	r3, [r7, #4]
20000c0e:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
20000c12:	687b      	ldr	r3, [r7, #4]
20000c14:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20000c18:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
20000c1c:	ea4f 1343 	mov.w	r3, r3, lsl #5
20000c20:	441a      	add	r2, r3
20000c22:	78fb      	ldrb	r3, [r7, #3]
20000c24:	ea4f 0383 	mov.w	r3, r3, lsl #2
20000c28:	4413      	add	r3, r2
20000c2a:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
20000c2e:	681b      	ldr	r3, [r3, #0]
20000c30:	b2db      	uxtb	r3, r3
}
20000c32:	4618      	mov	r0, r3
20000c34:	f107 070c 	add.w	r7, r7, #12
20000c38:	46bd      	mov	sp, r7
20000c3a:	bc80      	pop	{r7}
20000c3c:	4770      	bx	lr
20000c3e:	bf00      	nop

20000c40 <UART0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART0_IRQHandler(void)
#else
void UART0_IRQHandler(void)
#endif
{
20000c40:	4668      	mov	r0, sp
20000c42:	f020 0107 	bic.w	r1, r0, #7
20000c46:	468d      	mov	sp, r1
20000c48:	b589      	push	{r0, r3, r7, lr}
20000c4a:	af00      	add	r7, sp, #0
    MSS_UART_isr(&g_mss_uart0);
20000c4c:	f243 3000 	movw	r0, #13056	; 0x3300
20000c50:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000c54:	f000 f818 	bl	20000c88 <MSS_UART_isr>
}
20000c58:	46bd      	mov	sp, r7
20000c5a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
20000c5e:	4685      	mov	sp, r0
20000c60:	4770      	bx	lr
20000c62:	bf00      	nop

20000c64 <UART1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART1_IRQHandler(void)
#else
void UART1_IRQHandler(void)
#endif
{
20000c64:	4668      	mov	r0, sp
20000c66:	f020 0107 	bic.w	r1, r0, #7
20000c6a:	468d      	mov	sp, r1
20000c6c:	b589      	push	{r0, r3, r7, lr}
20000c6e:	af00      	add	r7, sp, #0
    MSS_UART_isr(&g_mss_uart1);
20000c70:	f243 20c0 	movw	r0, #12992	; 0x32c0
20000c74:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000c78:	f000 f806 	bl	20000c88 <MSS_UART_isr>
}
20000c7c:	46bd      	mov	sp, r7
20000c7e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
20000c82:	4685      	mov	sp, r0
20000c84:	4770      	bx	lr
20000c86:	bf00      	nop

20000c88 <MSS_UART_isr>:
static void
MSS_UART_isr
(
    mss_uart_instance_t * this_uart
)
{
20000c88:	b580      	push	{r7, lr}
20000c8a:	b084      	sub	sp, #16
20000c8c:	af00      	add	r7, sp, #0
20000c8e:	6078      	str	r0, [r7, #4]
    uint8_t iirf;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20000c90:	687a      	ldr	r2, [r7, #4]
20000c92:	f243 3300 	movw	r3, #13056	; 0x3300
20000c96:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c9a:	429a      	cmp	r2, r3
20000c9c:	d007      	beq.n	20000cae <MSS_UART_isr+0x26>
20000c9e:	687a      	ldr	r2, [r7, #4]
20000ca0:	f243 23c0 	movw	r3, #12992	; 0x32c0
20000ca4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ca8:	429a      	cmp	r2, r3
20000caa:	d000      	beq.n	20000cae <MSS_UART_isr+0x26>
20000cac:	be00      	bkpt	0x0000

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
20000cae:	687a      	ldr	r2, [r7, #4]
20000cb0:	f243 3300 	movw	r3, #13056	; 0x3300
20000cb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000cb8:	429a      	cmp	r2, r3
20000cba:	d007      	beq.n	20000ccc <MSS_UART_isr+0x44>
20000cbc:	687a      	ldr	r2, [r7, #4]
20000cbe:	f243 23c0 	movw	r3, #12992	; 0x32c0
20000cc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000cc6:	429a      	cmp	r2, r3
20000cc8:	f040 80ef 	bne.w	20000eaa <MSS_UART_isr+0x222>
    {
        iirf = this_uart->hw_reg->IIR & IIRF_MASK;
20000ccc:	687b      	ldr	r3, [r7, #4]
20000cce:	681b      	ldr	r3, [r3, #0]
20000cd0:	7a1b      	ldrb	r3, [r3, #8]
20000cd2:	b2db      	uxtb	r3, r3
20000cd4:	f003 030f 	and.w	r3, r3, #15
20000cd8:	73fb      	strb	r3, [r7, #15]

        switch (iirf)
20000cda:	7bfb      	ldrb	r3, [r7, #15]
20000cdc:	2b0c      	cmp	r3, #12
20000cde:	f200 80d7 	bhi.w	20000e90 <MSS_UART_isr+0x208>
20000ce2:	a201      	add	r2, pc, #4	; (adr r2, 20000ce8 <MSS_UART_isr+0x60>)
20000ce4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20000ce8:	20000d1d 	.word	0x20000d1d
20000cec:	20000e91 	.word	0x20000e91
20000cf0:	20000d3b 	.word	0x20000d3b
20000cf4:	20000d95 	.word	0x20000d95
20000cf8:	20000d59 	.word	0x20000d59
20000cfc:	20000e91 	.word	0x20000e91
20000d00:	20000d77 	.word	0x20000d77
20000d04:	20000e91 	.word	0x20000e91
20000d08:	20000e91 	.word	0x20000e91
20000d0c:	20000e91 	.word	0x20000e91
20000d10:	20000e91 	.word	0x20000e91
20000d14:	20000e91 	.word	0x20000e91
20000d18:	20000d59 	.word	0x20000d59
        {
            case IIRF_MODEM_STATUS:  /* Modem status interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->modemsts_handler);
20000d1c:	687b      	ldr	r3, [r7, #4]
20000d1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20000d20:	2b00      	cmp	r3, #0
20000d22:	d100      	bne.n	20000d26 <MSS_UART_isr+0x9e>
20000d24:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->modemsts_handler)
20000d26:	687b      	ldr	r3, [r7, #4]
20000d28:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20000d2a:	2b00      	cmp	r3, #0
20000d2c:	f000 80b2 	beq.w	20000e94 <MSS_UART_isr+0x20c>
                {
                   (*(this_uart->modemsts_handler))(this_uart);
20000d30:	687b      	ldr	r3, [r7, #4]
20000d32:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20000d34:	6878      	ldr	r0, [r7, #4]
20000d36:	4798      	blx	r3
                }
            }
            break;
20000d38:	e0b7      	b.n	20000eaa <MSS_UART_isr+0x222>

            case IIRF_THRE: /* Transmitter Holding Register Empty */
            {
                ASSERT(NULL_HANDLER != this_uart->tx_handler);
20000d3a:	687b      	ldr	r3, [r7, #4]
20000d3c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20000d3e:	2b00      	cmp	r3, #0
20000d40:	d100      	bne.n	20000d44 <MSS_UART_isr+0xbc>
20000d42:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->tx_handler)
20000d44:	687b      	ldr	r3, [r7, #4]
20000d46:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20000d48:	2b00      	cmp	r3, #0
20000d4a:	f000 80a5 	beq.w	20000e98 <MSS_UART_isr+0x210>
                {
                    (*(this_uart->tx_handler))(this_uart);
20000d4e:	687b      	ldr	r3, [r7, #4]
20000d50:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20000d52:	6878      	ldr	r0, [r7, #4]
20000d54:	4798      	blx	r3
                }
            }
            break;
20000d56:	e0a8      	b.n	20000eaa <MSS_UART_isr+0x222>

            case IIRF_RX_DATA:      /* Received Data Available */
            case IIRF_DATA_TIMEOUT: /* Received Data Timed-out */
            {
                ASSERT(NULL_HANDLER != this_uart->rx_handler);
20000d58:	687b      	ldr	r3, [r7, #4]
20000d5a:	6a1b      	ldr	r3, [r3, #32]
20000d5c:	2b00      	cmp	r3, #0
20000d5e:	d100      	bne.n	20000d62 <MSS_UART_isr+0xda>
20000d60:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->rx_handler)
20000d62:	687b      	ldr	r3, [r7, #4]
20000d64:	6a1b      	ldr	r3, [r3, #32]
20000d66:	2b00      	cmp	r3, #0
20000d68:	f000 8098 	beq.w	20000e9c <MSS_UART_isr+0x214>
                {
                    (*(this_uart->rx_handler))(this_uart);
20000d6c:	687b      	ldr	r3, [r7, #4]
20000d6e:	6a1b      	ldr	r3, [r3, #32]
20000d70:	6878      	ldr	r0, [r7, #4]
20000d72:	4798      	blx	r3
                }
            }
            break;
20000d74:	e099      	b.n	20000eaa <MSS_UART_isr+0x222>

            case IIRF_RX_LINE_STATUS:  /* Line Status Interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->linests_handler);
20000d76:	687b      	ldr	r3, [r7, #4]
20000d78:	69db      	ldr	r3, [r3, #28]
20000d7a:	2b00      	cmp	r3, #0
20000d7c:	d100      	bne.n	20000d80 <MSS_UART_isr+0xf8>
20000d7e:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->linests_handler)
20000d80:	687b      	ldr	r3, [r7, #4]
20000d82:	69db      	ldr	r3, [r3, #28]
20000d84:	2b00      	cmp	r3, #0
20000d86:	f000 808b 	beq.w	20000ea0 <MSS_UART_isr+0x218>
                {
                   (*(this_uart->linests_handler))(this_uart);
20000d8a:	687b      	ldr	r3, [r7, #4]
20000d8c:	69db      	ldr	r3, [r3, #28]
20000d8e:	6878      	ldr	r0, [r7, #4]
20000d90:	4798      	blx	r3
                }
            }
            break;
20000d92:	e08a      	b.n	20000eaa <MSS_UART_isr+0x222>
            case IIRF_MMI:
            {
                /* Identify multimode interrupts and handle */

                /* Receiver time-out interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ERTOI))
20000d94:	687b      	ldr	r3, [r7, #4]
20000d96:	681b      	ldr	r3, [r3, #0]
20000d98:	f103 0328 	add.w	r3, r3, #40	; 0x28
20000d9c:	4618      	mov	r0, r3
20000d9e:	f04f 0100 	mov.w	r1, #0
20000da2:	f7ff ff2d 	bl	20000c00 <read_bit_reg8>
20000da6:	4603      	mov	r3, r0
20000da8:	2b00      	cmp	r3, #0
20000daa:	d00c      	beq.n	20000dc6 <MSS_UART_isr+0x13e>
                {
                    ASSERT(NULL_HANDLER != this_uart->rto_handler);
20000dac:	687b      	ldr	r3, [r7, #4]
20000dae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20000db0:	2b00      	cmp	r3, #0
20000db2:	d100      	bne.n	20000db6 <MSS_UART_isr+0x12e>
20000db4:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->rto_handler)
20000db6:	687b      	ldr	r3, [r7, #4]
20000db8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20000dba:	2b00      	cmp	r3, #0
20000dbc:	d003      	beq.n	20000dc6 <MSS_UART_isr+0x13e>
                    {
                        (*(this_uart->rto_handler))(this_uart);
20000dbe:	687b      	ldr	r3, [r7, #4]
20000dc0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20000dc2:	6878      	ldr	r0, [r7, #4]
20000dc4:	4798      	blx	r3
                    }
                }
                /* NACK interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ENACKI))
20000dc6:	687b      	ldr	r3, [r7, #4]
20000dc8:	681b      	ldr	r3, [r3, #0]
20000dca:	f103 0328 	add.w	r3, r3, #40	; 0x28
20000dce:	4618      	mov	r0, r3
20000dd0:	f04f 0101 	mov.w	r1, #1
20000dd4:	f7ff ff14 	bl	20000c00 <read_bit_reg8>
20000dd8:	4603      	mov	r3, r0
20000dda:	2b00      	cmp	r3, #0
20000ddc:	d00c      	beq.n	20000df8 <MSS_UART_isr+0x170>
                {
                    ASSERT(NULL_HANDLER != this_uart->nack_handler);
20000dde:	687b      	ldr	r3, [r7, #4]
20000de0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20000de2:	2b00      	cmp	r3, #0
20000de4:	d100      	bne.n	20000de8 <MSS_UART_isr+0x160>
20000de6:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->nack_handler)
20000de8:	687b      	ldr	r3, [r7, #4]
20000dea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20000dec:	2b00      	cmp	r3, #0
20000dee:	d003      	beq.n	20000df8 <MSS_UART_isr+0x170>
                    {
                        (*(this_uart->nack_handler))(this_uart);
20000df0:	687b      	ldr	r3, [r7, #4]
20000df2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20000df4:	6878      	ldr	r0, [r7, #4]
20000df6:	4798      	blx	r3
                    }
                }

                /* PID parity error interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,EPID_PEI))
20000df8:	687b      	ldr	r3, [r7, #4]
20000dfa:	681b      	ldr	r3, [r3, #0]
20000dfc:	f103 0328 	add.w	r3, r3, #40	; 0x28
20000e00:	4618      	mov	r0, r3
20000e02:	f04f 0102 	mov.w	r1, #2
20000e06:	f7ff fefb 	bl	20000c00 <read_bit_reg8>
20000e0a:	4603      	mov	r3, r0
20000e0c:	2b00      	cmp	r3, #0
20000e0e:	d00c      	beq.n	20000e2a <MSS_UART_isr+0x1a2>
                {
                    ASSERT(NULL_HANDLER != this_uart->pid_pei_handler);
20000e10:	687b      	ldr	r3, [r7, #4]
20000e12:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20000e14:	2b00      	cmp	r3, #0
20000e16:	d100      	bne.n	20000e1a <MSS_UART_isr+0x192>
20000e18:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->pid_pei_handler)
20000e1a:	687b      	ldr	r3, [r7, #4]
20000e1c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20000e1e:	2b00      	cmp	r3, #0
20000e20:	d003      	beq.n	20000e2a <MSS_UART_isr+0x1a2>
                    {
                        (*(this_uart->pid_pei_handler))(this_uart);
20000e22:	687b      	ldr	r3, [r7, #4]
20000e24:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20000e26:	6878      	ldr	r0, [r7, #4]
20000e28:	4798      	blx	r3
                    }
                }

                /* LIN break detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINBI))
20000e2a:	687b      	ldr	r3, [r7, #4]
20000e2c:	681b      	ldr	r3, [r3, #0]
20000e2e:	f103 0328 	add.w	r3, r3, #40	; 0x28
20000e32:	4618      	mov	r0, r3
20000e34:	f04f 0103 	mov.w	r1, #3
20000e38:	f7ff fee2 	bl	20000c00 <read_bit_reg8>
20000e3c:	4603      	mov	r3, r0
20000e3e:	2b00      	cmp	r3, #0
20000e40:	d00c      	beq.n	20000e5c <MSS_UART_isr+0x1d4>
                {
                    ASSERT(NULL_HANDLER != this_uart->break_handler);
20000e42:	687b      	ldr	r3, [r7, #4]
20000e44:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20000e46:	2b00      	cmp	r3, #0
20000e48:	d100      	bne.n	20000e4c <MSS_UART_isr+0x1c4>
20000e4a:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->break_handler)
20000e4c:	687b      	ldr	r3, [r7, #4]
20000e4e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20000e50:	2b00      	cmp	r3, #0
20000e52:	d003      	beq.n	20000e5c <MSS_UART_isr+0x1d4>
                    {
                        (*(this_uart->break_handler))(this_uart);
20000e54:	687b      	ldr	r3, [r7, #4]
20000e56:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20000e58:	6878      	ldr	r0, [r7, #4]
20000e5a:	4798      	blx	r3
                    }
                }

                /* LIN Sync detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINSI))
20000e5c:	687b      	ldr	r3, [r7, #4]
20000e5e:	681b      	ldr	r3, [r3, #0]
20000e60:	f103 0328 	add.w	r3, r3, #40	; 0x28
20000e64:	4618      	mov	r0, r3
20000e66:	f04f 0104 	mov.w	r1, #4
20000e6a:	f7ff fec9 	bl	20000c00 <read_bit_reg8>
20000e6e:	4603      	mov	r3, r0
20000e70:	2b00      	cmp	r3, #0
20000e72:	d017      	beq.n	20000ea4 <MSS_UART_isr+0x21c>
                {
                    ASSERT(NULL_HANDLER != this_uart->sync_handler);
20000e74:	687b      	ldr	r3, [r7, #4]
20000e76:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20000e78:	2b00      	cmp	r3, #0
20000e7a:	d100      	bne.n	20000e7e <MSS_UART_isr+0x1f6>
20000e7c:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->sync_handler)
20000e7e:	687b      	ldr	r3, [r7, #4]
20000e80:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20000e82:	2b00      	cmp	r3, #0
20000e84:	d010      	beq.n	20000ea8 <MSS_UART_isr+0x220>
                    {
                        (*(this_uart->sync_handler))(this_uart);
20000e86:	687b      	ldr	r3, [r7, #4]
20000e88:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20000e8a:	6878      	ldr	r0, [r7, #4]
20000e8c:	4798      	blx	r3
                    }
                }
                break;
20000e8e:	e00c      	b.n	20000eaa <MSS_UART_isr+0x222>
            }

            default:
            {
                ASSERT(INVALID_INTERRUPT);
20000e90:	be00      	bkpt	0x0000
20000e92:	e00a      	b.n	20000eaa <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->modemsts_handler)
                {
                   (*(this_uart->modemsts_handler))(this_uart);
                }
            }
            break;
20000e94:	bf00      	nop
20000e96:	e008      	b.n	20000eaa <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->tx_handler)
                {
                    (*(this_uart->tx_handler))(this_uart);
                }
            }
            break;
20000e98:	bf00      	nop
20000e9a:	e006      	b.n	20000eaa <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->rx_handler)
                {
                    (*(this_uart->rx_handler))(this_uart);
                }
            }
            break;
20000e9c:	bf00      	nop
20000e9e:	e004      	b.n	20000eaa <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->linests_handler)
                {
                   (*(this_uart->linests_handler))(this_uart);
                }
            }
            break;
20000ea0:	bf00      	nop
20000ea2:	e002      	b.n	20000eaa <MSS_UART_isr+0x222>
                    if(NULL_HANDLER != this_uart->sync_handler)
                    {
                        (*(this_uart->sync_handler))(this_uart);
                    }
                }
                break;
20000ea4:	bf00      	nop
20000ea6:	e000      	b.n	20000eaa <MSS_UART_isr+0x222>
20000ea8:	bf00      	nop
                ASSERT(INVALID_INTERRUPT);
            }
            break;
        }
    }
}
20000eaa:	f107 0710 	add.w	r7, r7, #16
20000eae:	46bd      	mov	sp, r7
20000eb0:	bd80      	pop	{r7, pc}
20000eb2:	bf00      	nop

20000eb4 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
20000eb4:	b480      	push	{r7}
20000eb6:	b083      	sub	sp, #12
20000eb8:	af00      	add	r7, sp, #0
20000eba:	4603      	mov	r3, r0
20000ebc:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
20000ebe:	f24e 1300 	movw	r3, #57600	; 0xe100
20000ec2:	f2ce 0300 	movt	r3, #57344	; 0xe000
20000ec6:	f997 2007 	ldrsb.w	r2, [r7, #7]
20000eca:	ea4f 1252 	mov.w	r2, r2, lsr #5
20000ece:	79f9      	ldrb	r1, [r7, #7]
20000ed0:	f001 011f 	and.w	r1, r1, #31
20000ed4:	f04f 0001 	mov.w	r0, #1
20000ed8:	fa00 f101 	lsl.w	r1, r0, r1
20000edc:	f102 0220 	add.w	r2, r2, #32
20000ee0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20000ee4:	f107 070c 	add.w	r7, r7, #12
20000ee8:	46bd      	mov	sp, r7
20000eea:	bc80      	pop	{r7}
20000eec:	4770      	bx	lr
20000eee:	bf00      	nop

20000ef0 <enable_slave_if_required>:
 */
static void enable_slave_if_required
(
    mss_i2c_instance_t * this_i2c
)
{
20000ef0:	b480      	push	{r7}
20000ef2:	b083      	sub	sp, #12
20000ef4:	af00      	add	r7, sp, #0
20000ef6:	6078      	str	r0, [r7, #4]
    if( this_i2c->is_slave_enabled )
20000ef8:	687b      	ldr	r3, [r7, #4]
20000efa:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
20000efe:	2b00      	cmp	r3, #0
20000f00:	d004      	beq.n	20000f0c <enable_slave_if_required+0x1c>
    {
        this_i2c->hw_reg_bit->CTRL_AA = 1u;
20000f02:	687b      	ldr	r3, [r7, #4]
20000f04:	699b      	ldr	r3, [r3, #24]
20000f06:	f04f 0201 	mov.w	r2, #1
20000f0a:	609a      	str	r2, [r3, #8]
    }
}
20000f0c:	f107 070c 	add.w	r7, r7, #12
20000f10:	46bd      	mov	sp, r7
20000f12:	bc80      	pop	{r7}
20000f14:	4770      	bx	lr
20000f16:	bf00      	nop

20000f18 <mss_i2c_isr>:
 */
static void mss_i2c_isr
(
    mss_i2c_instance_t * this_i2c
)
{
20000f18:	b580      	push	{r7, lr}
20000f1a:	b084      	sub	sp, #16
20000f1c:	af00      	add	r7, sp, #0
20000f1e:	6078      	str	r0, [r7, #4]
    volatile uint8_t status;
    uint8_t data;
    uint8_t hold_bus;
    uint8_t clear_irq = 1u;
20000f20:	f04f 0301 	mov.w	r3, #1
20000f24:	73bb      	strb	r3, [r7, #14]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
20000f26:	687a      	ldr	r2, [r7, #4]
20000f28:	f243 3340 	movw	r3, #13120	; 0x3340
20000f2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f30:	429a      	cmp	r2, r3
20000f32:	d007      	beq.n	20000f44 <mss_i2c_isr+0x2c>
20000f34:	687a      	ldr	r2, [r7, #4]
20000f36:	f243 33b4 	movw	r3, #13236	; 0x33b4
20000f3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f3e:	429a      	cmp	r2, r3
20000f40:	d000      	beq.n	20000f44 <mss_i2c_isr+0x2c>
20000f42:	be00      	bkpt	0x0000

    status = this_i2c->hw_reg->STATUS;
20000f44:	687b      	ldr	r3, [r7, #4]
20000f46:	695b      	ldr	r3, [r3, #20]
20000f48:	791b      	ldrb	r3, [r3, #4]
20000f4a:	72fb      	strb	r3, [r7, #11]

    switch( status )
20000f4c:	7afb      	ldrb	r3, [r7, #11]
20000f4e:	b2db      	uxtb	r3, r3
20000f50:	f1a3 0308 	sub.w	r3, r3, #8
20000f54:	2bd0      	cmp	r3, #208	; 0xd0
20000f56:	f200 841c 	bhi.w	20001792 <mss_i2c_isr+0x87a>
20000f5a:	a201      	add	r2, pc, #4	; (adr r2, 20000f60 <mss_i2c_isr+0x48>)
20000f5c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20000f60:	200012a5 	.word	0x200012a5
20000f64:	20001793 	.word	0x20001793
20000f68:	20001793 	.word	0x20001793
20000f6c:	20001793 	.word	0x20001793
20000f70:	20001793 	.word	0x20001793
20000f74:	20001793 	.word	0x20001793
20000f78:	20001793 	.word	0x20001793
20000f7c:	20001793 	.word	0x20001793
20000f80:	200012a5 	.word	0x200012a5
20000f84:	20001793 	.word	0x20001793
20000f88:	20001793 	.word	0x20001793
20000f8c:	20001793 	.word	0x20001793
20000f90:	20001793 	.word	0x20001793
20000f94:	20001793 	.word	0x20001793
20000f98:	20001793 	.word	0x20001793
20000f9c:	20001793 	.word	0x20001793
20000fa0:	20001349 	.word	0x20001349
20000fa4:	20001793 	.word	0x20001793
20000fa8:	20001793 	.word	0x20001793
20000fac:	20001793 	.word	0x20001793
20000fb0:	20001793 	.word	0x20001793
20000fb4:	20001793 	.word	0x20001793
20000fb8:	20001793 	.word	0x20001793
20000fbc:	20001793 	.word	0x20001793
20000fc0:	20001325 	.word	0x20001325
20000fc4:	20001793 	.word	0x20001793
20000fc8:	20001793 	.word	0x20001793
20000fcc:	20001793 	.word	0x20001793
20000fd0:	20001793 	.word	0x20001793
20000fd4:	20001793 	.word	0x20001793
20000fd8:	20001793 	.word	0x20001793
20000fdc:	20001793 	.word	0x20001793
20000fe0:	20001349 	.word	0x20001349
20000fe4:	20001793 	.word	0x20001793
20000fe8:	20001793 	.word	0x20001793
20000fec:	20001793 	.word	0x20001793
20000ff0:	20001793 	.word	0x20001793
20000ff4:	20001793 	.word	0x20001793
20000ff8:	20001793 	.word	0x20001793
20000ffc:	20001793 	.word	0x20001793
20001000:	200013dd 	.word	0x200013dd
20001004:	20001793 	.word	0x20001793
20001008:	20001793 	.word	0x20001793
2000100c:	20001793 	.word	0x20001793
20001010:	20001793 	.word	0x20001793
20001014:	20001793 	.word	0x20001793
20001018:	20001793 	.word	0x20001793
2000101c:	20001793 	.word	0x20001793
20001020:	20001319 	.word	0x20001319
20001024:	20001793 	.word	0x20001793
20001028:	20001793 	.word	0x20001793
2000102c:	20001793 	.word	0x20001793
20001030:	20001793 	.word	0x20001793
20001034:	20001793 	.word	0x20001793
20001038:	20001793 	.word	0x20001793
2000103c:	20001793 	.word	0x20001793
20001040:	20001401 	.word	0x20001401
20001044:	20001793 	.word	0x20001793
20001048:	20001793 	.word	0x20001793
2000104c:	20001793 	.word	0x20001793
20001050:	20001793 	.word	0x20001793
20001054:	20001793 	.word	0x20001793
20001058:	20001793 	.word	0x20001793
2000105c:	20001793 	.word	0x20001793
20001060:	20001451 	.word	0x20001451
20001064:	20001793 	.word	0x20001793
20001068:	20001793 	.word	0x20001793
2000106c:	20001793 	.word	0x20001793
20001070:	20001793 	.word	0x20001793
20001074:	20001793 	.word	0x20001793
20001078:	20001793 	.word	0x20001793
2000107c:	20001793 	.word	0x20001793
20001080:	20001475 	.word	0x20001475
20001084:	20001793 	.word	0x20001793
20001088:	20001793 	.word	0x20001793
2000108c:	20001793 	.word	0x20001793
20001090:	20001793 	.word	0x20001793
20001094:	20001793 	.word	0x20001793
20001098:	20001793 	.word	0x20001793
2000109c:	20001793 	.word	0x20001793
200010a0:	200014af 	.word	0x200014af
200010a4:	20001793 	.word	0x20001793
200010a8:	20001793 	.word	0x20001793
200010ac:	20001793 	.word	0x20001793
200010b0:	20001793 	.word	0x20001793
200010b4:	20001793 	.word	0x20001793
200010b8:	20001793 	.word	0x20001793
200010bc:	20001793 	.word	0x20001793
200010c0:	20001551 	.word	0x20001551
200010c4:	20001793 	.word	0x20001793
200010c8:	20001793 	.word	0x20001793
200010cc:	20001793 	.word	0x20001793
200010d0:	20001793 	.word	0x20001793
200010d4:	20001793 	.word	0x20001793
200010d8:	20001793 	.word	0x20001793
200010dc:	20001793 	.word	0x20001793
200010e0:	20001547 	.word	0x20001547
200010e4:	20001793 	.word	0x20001793
200010e8:	20001793 	.word	0x20001793
200010ec:	20001793 	.word	0x20001793
200010f0:	20001793 	.word	0x20001793
200010f4:	20001793 	.word	0x20001793
200010f8:	20001793 	.word	0x20001793
200010fc:	20001793 	.word	0x20001793
20001100:	20001551 	.word	0x20001551
20001104:	20001793 	.word	0x20001793
20001108:	20001793 	.word	0x20001793
2000110c:	20001793 	.word	0x20001793
20001110:	20001793 	.word	0x20001793
20001114:	20001793 	.word	0x20001793
20001118:	20001793 	.word	0x20001793
2000111c:	20001793 	.word	0x20001793
20001120:	20001547 	.word	0x20001547
20001124:	20001793 	.word	0x20001793
20001128:	20001793 	.word	0x20001793
2000112c:	20001793 	.word	0x20001793
20001130:	20001793 	.word	0x20001793
20001134:	20001793 	.word	0x20001793
20001138:	20001793 	.word	0x20001793
2000113c:	20001793 	.word	0x20001793
20001140:	20001593 	.word	0x20001593
20001144:	20001793 	.word	0x20001793
20001148:	20001793 	.word	0x20001793
2000114c:	20001793 	.word	0x20001793
20001150:	20001793 	.word	0x20001793
20001154:	20001793 	.word	0x20001793
20001158:	20001793 	.word	0x20001793
2000115c:	20001793 	.word	0x20001793
20001160:	20001513 	.word	0x20001513
20001164:	20001793 	.word	0x20001793
20001168:	20001793 	.word	0x20001793
2000116c:	20001793 	.word	0x20001793
20001170:	20001793 	.word	0x20001793
20001174:	20001793 	.word	0x20001793
20001178:	20001793 	.word	0x20001793
2000117c:	20001793 	.word	0x20001793
20001180:	20001593 	.word	0x20001593
20001184:	20001793 	.word	0x20001793
20001188:	20001793 	.word	0x20001793
2000118c:	20001793 	.word	0x20001793
20001190:	20001793 	.word	0x20001793
20001194:	20001793 	.word	0x20001793
20001198:	20001793 	.word	0x20001793
2000119c:	20001793 	.word	0x20001793
200011a0:	20001513 	.word	0x20001513
200011a4:	20001793 	.word	0x20001793
200011a8:	20001793 	.word	0x20001793
200011ac:	20001793 	.word	0x20001793
200011b0:	20001793 	.word	0x20001793
200011b4:	20001793 	.word	0x20001793
200011b8:	20001793 	.word	0x20001793
200011bc:	20001793 	.word	0x20001793
200011c0:	200015ef 	.word	0x200015ef
200011c4:	20001793 	.word	0x20001793
200011c8:	20001793 	.word	0x20001793
200011cc:	20001793 	.word	0x20001793
200011d0:	20001793 	.word	0x20001793
200011d4:	20001793 	.word	0x20001793
200011d8:	20001793 	.word	0x20001793
200011dc:	20001793 	.word	0x20001793
200011e0:	200016c7 	.word	0x200016c7
200011e4:	20001793 	.word	0x20001793
200011e8:	20001793 	.word	0x20001793
200011ec:	20001793 	.word	0x20001793
200011f0:	20001793 	.word	0x20001793
200011f4:	20001793 	.word	0x20001793
200011f8:	20001793 	.word	0x20001793
200011fc:	20001793 	.word	0x20001793
20001200:	200016c7 	.word	0x200016c7
20001204:	20001793 	.word	0x20001793
20001208:	20001793 	.word	0x20001793
2000120c:	20001793 	.word	0x20001793
20001210:	20001793 	.word	0x20001793
20001214:	20001793 	.word	0x20001793
20001218:	20001793 	.word	0x20001793
2000121c:	20001793 	.word	0x20001793
20001220:	200016c7 	.word	0x200016c7
20001224:	20001793 	.word	0x20001793
20001228:	20001793 	.word	0x20001793
2000122c:	20001793 	.word	0x20001793
20001230:	20001793 	.word	0x20001793
20001234:	20001793 	.word	0x20001793
20001238:	20001793 	.word	0x20001793
2000123c:	20001793 	.word	0x20001793
20001240:	20001759 	.word	0x20001759
20001244:	20001793 	.word	0x20001793
20001248:	20001793 	.word	0x20001793
2000124c:	20001793 	.word	0x20001793
20001250:	20001793 	.word	0x20001793
20001254:	20001793 	.word	0x20001793
20001258:	20001793 	.word	0x20001793
2000125c:	20001793 	.word	0x20001793
20001260:	20001759 	.word	0x20001759
20001264:	20001793 	.word	0x20001793
20001268:	20001793 	.word	0x20001793
2000126c:	20001793 	.word	0x20001793
20001270:	20001793 	.word	0x20001793
20001274:	20001793 	.word	0x20001793
20001278:	20001793 	.word	0x20001793
2000127c:	20001793 	.word	0x20001793
20001280:	20001793 	.word	0x20001793
20001284:	20001793 	.word	0x20001793
20001288:	20001793 	.word	0x20001793
2000128c:	20001793 	.word	0x20001793
20001290:	20001793 	.word	0x20001793
20001294:	20001793 	.word	0x20001793
20001298:	20001793 	.word	0x20001793
2000129c:	20001793 	.word	0x20001793
200012a0:	20001699 	.word	0x20001699
    {
        /************** MASTER TRANSMITTER / RECEIVER *******************/
      
        case ST_START: /* start has been xmt'd */
        case ST_RESTART: /* repeated start has been xmt'd */
            this_i2c->hw_reg_bit->CTRL_STA = 0u;
200012a4:	687b      	ldr	r3, [r7, #4]
200012a6:	699b      	ldr	r3, [r3, #24]
200012a8:	f04f 0200 	mov.w	r2, #0
200012ac:	615a      	str	r2, [r3, #20]
            this_i2c->hw_reg->DATA = (uint8_t)this_i2c->target_addr;
200012ae:	687b      	ldr	r3, [r7, #4]
200012b0:	695b      	ldr	r3, [r3, #20]
200012b2:	687a      	ldr	r2, [r7, #4]
200012b4:	6852      	ldr	r2, [r2, #4]
200012b6:	b2d2      	uxtb	r2, r2
200012b8:	721a      	strb	r2, [r3, #8]
            this_i2c->hw_reg_bit->DATA_DIR = this_i2c->dir;
200012ba:	687b      	ldr	r3, [r7, #4]
200012bc:	699b      	ldr	r3, [r3, #24]
200012be:	687a      	ldr	r2, [r7, #4]
200012c0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
200012c2:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
            if ( this_i2c->dir == WRITE_DIR )
200012c6:	687b      	ldr	r3, [r7, #4]
200012c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200012ca:	2b00      	cmp	r3, #0
200012cc:	d104      	bne.n	200012d8 <mss_i2c_isr+0x3c0>
            {
                this_i2c->master_tx_idx = 0u;
200012ce:	687b      	ldr	r3, [r7, #4]
200012d0:	f04f 0200 	mov.w	r2, #0
200012d4:	629a      	str	r2, [r3, #40]	; 0x28
200012d6:	e007      	b.n	200012e8 <mss_i2c_isr+0x3d0>
            }
            else if ( this_i2c->dir == READ_DIR)
200012d8:	687b      	ldr	r3, [r7, #4]
200012da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200012dc:	2b01      	cmp	r3, #1
200012de:	d103      	bne.n	200012e8 <mss_i2c_isr+0x3d0>
            {
                this_i2c->master_rx_idx = 0u;
200012e0:	687b      	ldr	r3, [r7, #4]
200012e2:	f04f 0200 	mov.w	r2, #0
200012e6:	639a      	str	r2, [r3, #56]	; 0x38
            /*
             * Clear the pending transaction. This condition will be true if the slave 
             * has acquired the bus to carry out pending master transaction which 
             * it had received during its slave transmission or reception mode. 
             */
            if(this_i2c->is_transaction_pending)
200012e8:	687b      	ldr	r3, [r7, #4]
200012ea:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
200012ee:	2b00      	cmp	r3, #0
200012f0:	d004      	beq.n	200012fc <mss_i2c_isr+0x3e4>
            {
                this_i2c->is_transaction_pending = 0u;
200012f2:	687b      	ldr	r3, [r7, #4]
200012f4:	f04f 0200 	mov.w	r2, #0
200012f8:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71

            /*
             * Make sure to update proper transaction after master START
             * or RESTART
             */
            if(this_i2c->transaction != this_i2c->pending_transaction)
200012fc:	687b      	ldr	r3, [r7, #4]
200012fe:	7a1a      	ldrb	r2, [r3, #8]
20001300:	687b      	ldr	r3, [r7, #4]
20001302:	f893 3072 	ldrb.w	r3, [r3, #114]	; 0x72
20001306:	429a      	cmp	r2, r3
20001308:	f000 8267 	beq.w	200017da <mss_i2c_isr+0x8c2>
            {
                this_i2c->transaction = this_i2c->pending_transaction;
2000130c:	687b      	ldr	r3, [r7, #4]
2000130e:	f893 2072 	ldrb.w	r2, [r3, #114]	; 0x72
20001312:	687b      	ldr	r3, [r7, #4]
20001314:	721a      	strb	r2, [r3, #8]
            }
            break;
20001316:	e269      	b.n	200017ec <mss_i2c_isr+0x8d4>
            
        case ST_LOST_ARB:
            /* Set start bit.  Let's keep trying!  Don't give up! */
            this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
20001318:	687b      	ldr	r3, [r7, #4]
2000131a:	699b      	ldr	r3, [r3, #24]
2000131c:	f04f 0201 	mov.w	r2, #1
20001320:	615a      	str	r2, [r3, #20]
            break;
20001322:	e263      	b.n	200017ec <mss_i2c_isr+0x8d4>
            
        /******************* MASTER TRANSMITTER *************************/
        case ST_SLAW_NACK:
            /* SLA+W has been transmitted; not ACK has been received - let's stop. */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
20001324:	687b      	ldr	r3, [r7, #4]
20001326:	699b      	ldr	r3, [r3, #24]
20001328:	f04f 0201 	mov.w	r2, #1
2000132c:	611a      	str	r2, [r3, #16]
            this_i2c->master_status = MSS_I2C_FAILED;
2000132e:	687b      	ldr	r3, [r7, #4]
20001330:	f04f 0202 	mov.w	r2, #2
20001334:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            this_i2c->transaction = NO_TRANSACTION;
20001338:	687b      	ldr	r3, [r7, #4]
2000133a:	f04f 0200 	mov.w	r2, #0
2000133e:	721a      	strb	r2, [r3, #8]
            enable_slave_if_required(this_i2c);
20001340:	6878      	ldr	r0, [r7, #4]
20001342:	f7ff fdd5 	bl	20000ef0 <enable_slave_if_required>
            break;
20001346:	e251      	b.n	200017ec <mss_i2c_isr+0x8d4>
            
        case ST_SLAW_ACK:
        case ST_TX_DATA_ACK:
            /* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
            if (this_i2c->master_tx_idx < this_i2c->master_tx_size)
20001348:	687b      	ldr	r3, [r7, #4]
2000134a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2000134c:	687b      	ldr	r3, [r7, #4]
2000134e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20001350:	429a      	cmp	r2, r3
20001352:	d20d      	bcs.n	20001370 <mss_i2c_isr+0x458>
            {    
                this_i2c->hw_reg->DATA = this_i2c->master_tx_buffer[this_i2c->master_tx_idx++];
20001354:	687b      	ldr	r3, [r7, #4]
20001356:	695a      	ldr	r2, [r3, #20]
20001358:	687b      	ldr	r3, [r7, #4]
2000135a:	6a19      	ldr	r1, [r3, #32]
2000135c:	687b      	ldr	r3, [r7, #4]
2000135e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20001360:	4419      	add	r1, r3
20001362:	7809      	ldrb	r1, [r1, #0]
20001364:	7211      	strb	r1, [r2, #8]
20001366:	f103 0201 	add.w	r2, r3, #1
2000136a:	687b      	ldr	r3, [r7, #4]
2000136c:	629a      	str	r2, [r3, #40]	; 0x28
                    NVIC_DisableIRQ( this_i2c->irqn );
                    clear_irq = 0u;
                }
                this_i2c->master_status = MSS_I2C_SUCCESS;
            }
            break;
2000136e:	e23d      	b.n	200017ec <mss_i2c_isr+0x8d4>
            /* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
            if (this_i2c->master_tx_idx < this_i2c->master_tx_size)
            {    
                this_i2c->hw_reg->DATA = this_i2c->master_tx_buffer[this_i2c->master_tx_idx++];
            }
            else if ( this_i2c->transaction == MASTER_RANDOM_READ_TRANSACTION )
20001370:	687b      	ldr	r3, [r7, #4]
20001372:	7a1b      	ldrb	r3, [r3, #8]
20001374:	2b03      	cmp	r3, #3
20001376:	d109      	bne.n	2000138c <mss_i2c_isr+0x474>
            {
                /* We are finished sending the address offset part of a random read transaction.
                 * It is is time to send a restart in order to change direction. */
                 this_i2c->dir = READ_DIR;
20001378:	687b      	ldr	r3, [r7, #4]
2000137a:	f04f 0201 	mov.w	r2, #1
2000137e:	62da      	str	r2, [r3, #44]	; 0x2c
                 this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
20001380:	687b      	ldr	r3, [r7, #4]
20001382:	699b      	ldr	r3, [r3, #24]
20001384:	f04f 0201 	mov.w	r2, #1
20001388:	615a      	str	r2, [r3, #20]
                    NVIC_DisableIRQ( this_i2c->irqn );
                    clear_irq = 0u;
                }
                this_i2c->master_status = MSS_I2C_SUCCESS;
            }
            break;
2000138a:	e22f      	b.n	200017ec <mss_i2c_isr+0x8d4>
            {
                /*
                 * Set the transaction back to NO_TRANSACTION to allow user to do further
                 * transaction
                 */
                this_i2c->transaction = NO_TRANSACTION;
2000138c:	687b      	ldr	r3, [r7, #4]
2000138e:	f04f 0200 	mov.w	r2, #0
20001392:	721a      	strb	r2, [r3, #8]
                hold_bus = this_i2c->options & MSS_I2C_HOLD_BUS;
20001394:	687b      	ldr	r3, [r7, #4]
20001396:	7c1b      	ldrb	r3, [r3, #16]
20001398:	f003 0301 	and.w	r3, r3, #1
2000139c:	737b      	strb	r3, [r7, #13]

                /* Store the information of current I2C bus status in the bus_status*/
                this_i2c->bus_status  = hold_bus;
2000139e:	687b      	ldr	r3, [r7, #4]
200013a0:	7b7a      	ldrb	r2, [r7, #13]
200013a2:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
                if ( hold_bus == 0u )
200013a6:	7b7b      	ldrb	r3, [r7, #13]
200013a8:	2b00      	cmp	r3, #0
200013aa:	d108      	bne.n	200013be <mss_i2c_isr+0x4a6>
                { 
                    this_i2c->hw_reg_bit->CTRL_STO = 0x01u; /*xmt stop condition */
200013ac:	687b      	ldr	r3, [r7, #4]
200013ae:	699b      	ldr	r3, [r3, #24]
200013b0:	f04f 0201 	mov.w	r2, #1
200013b4:	611a      	str	r2, [r3, #16]
                    enable_slave_if_required(this_i2c);
200013b6:	6878      	ldr	r0, [r7, #4]
200013b8:	f7ff fd9a 	bl	20000ef0 <enable_slave_if_required>
200013bc:	e008      	b.n	200013d0 <mss_i2c_isr+0x4b8>
                }
                else
                {
                    NVIC_DisableIRQ( this_i2c->irqn );
200013be:	687b      	ldr	r3, [r7, #4]
200013c0:	7c5b      	ldrb	r3, [r3, #17]
200013c2:	b25b      	sxtb	r3, r3
200013c4:	4618      	mov	r0, r3
200013c6:	f7ff fd75 	bl	20000eb4 <NVIC_DisableIRQ>
                    clear_irq = 0u;
200013ca:	f04f 0300 	mov.w	r3, #0
200013ce:	73bb      	strb	r3, [r7, #14]
                }
                this_i2c->master_status = MSS_I2C_SUCCESS;
200013d0:	687b      	ldr	r3, [r7, #4]
200013d2:	f04f 0200 	mov.w	r2, #0
200013d6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            }
            break;
200013da:	e207      	b.n	200017ec <mss_i2c_isr+0x8d4>
            /* data byte SENT, ACK to be received
             * In fact, this means we've received a NACK (This may not be 
             * obvious, but if we've rec'd an ACK then we would be in state 
             * 0x28!) hence, let's send a stop bit
             */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
200013dc:	687b      	ldr	r3, [r7, #4]
200013de:	699b      	ldr	r3, [r3, #24]
200013e0:	f04f 0201 	mov.w	r2, #1
200013e4:	611a      	str	r2, [r3, #16]
            this_i2c->master_status = MSS_I2C_FAILED;
200013e6:	687b      	ldr	r3, [r7, #4]
200013e8:	f04f 0202 	mov.w	r2, #2
200013ec:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
200013f0:	687b      	ldr	r3, [r7, #4]
200013f2:	f04f 0200 	mov.w	r2, #0
200013f6:	721a      	strb	r2, [r3, #8]
            enable_slave_if_required(this_i2c);
200013f8:	6878      	ldr	r0, [r7, #4]
200013fa:	f7ff fd79 	bl	20000ef0 <enable_slave_if_required>

            break;
200013fe:	e1f5      	b.n	200017ec <mss_i2c_isr+0x8d4>
      /* STATUS codes 08H, 10H, 38H are all covered in MTX mode */
        case ST_SLAR_ACK: /* SLA+R tx'ed. */
            /* Let's make sure we ACK the first data byte received (set AA bit in CTRL) unless
             * the next byte is the last byte of the read transaction.
             */
            if(this_i2c->master_rx_size > 1u)
20001400:	687b      	ldr	r3, [r7, #4]
20001402:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20001404:	2b01      	cmp	r3, #1
20001406:	d905      	bls.n	20001414 <mss_i2c_isr+0x4fc>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
20001408:	687b      	ldr	r3, [r7, #4]
2000140a:	699b      	ldr	r3, [r3, #24]
2000140c:	f04f 0201 	mov.w	r2, #1
20001410:	609a      	str	r2, [r3, #8]
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
                this_i2c->master_status = MSS_I2C_SUCCESS;
                this_i2c->transaction = NO_TRANSACTION;
            }
            break;
20001412:	e1eb      	b.n	200017ec <mss_i2c_isr+0x8d4>
             */
            if(this_i2c->master_rx_size > 1u)
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
            }
            else if(1u == this_i2c->master_rx_size)
20001414:	687b      	ldr	r3, [r7, #4]
20001416:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20001418:	2b01      	cmp	r3, #1
2000141a:	d105      	bne.n	20001428 <mss_i2c_isr+0x510>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
2000141c:	687b      	ldr	r3, [r7, #4]
2000141e:	699b      	ldr	r3, [r3, #24]
20001420:	f04f 0200 	mov.w	r2, #0
20001424:	609a      	str	r2, [r3, #8]
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
                this_i2c->master_status = MSS_I2C_SUCCESS;
                this_i2c->transaction = NO_TRANSACTION;
            }
            break;
20001426:	e1e1      	b.n	200017ec <mss_i2c_isr+0x8d4>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
            }
            else /* this_i2c->master_rx_size == 0u */
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
20001428:	687b      	ldr	r3, [r7, #4]
2000142a:	699b      	ldr	r3, [r3, #24]
2000142c:	f04f 0201 	mov.w	r2, #1
20001430:	609a      	str	r2, [r3, #8]
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
20001432:	687b      	ldr	r3, [r7, #4]
20001434:	699b      	ldr	r3, [r3, #24]
20001436:	f04f 0201 	mov.w	r2, #1
2000143a:	611a      	str	r2, [r3, #16]
                this_i2c->master_status = MSS_I2C_SUCCESS;
2000143c:	687b      	ldr	r3, [r7, #4]
2000143e:	f04f 0200 	mov.w	r2, #0
20001442:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
                this_i2c->transaction = NO_TRANSACTION;
20001446:	687b      	ldr	r3, [r7, #4]
20001448:	f04f 0200 	mov.w	r2, #0
2000144c:	721a      	strb	r2, [r3, #8]
            }
            break;
2000144e:	e1cd      	b.n	200017ec <mss_i2c_isr+0x8d4>
            
        case ST_SLAR_NACK: /* SLA+R tx'ed; let's release the bus (send a stop condition) */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
20001450:	687b      	ldr	r3, [r7, #4]
20001452:	699b      	ldr	r3, [r3, #24]
20001454:	f04f 0201 	mov.w	r2, #1
20001458:	611a      	str	r2, [r3, #16]
            this_i2c->master_status = MSS_I2C_FAILED;
2000145a:	687b      	ldr	r3, [r7, #4]
2000145c:	f04f 0202 	mov.w	r2, #2
20001460:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
20001464:	687b      	ldr	r3, [r7, #4]
20001466:	f04f 0200 	mov.w	r2, #0
2000146a:	721a      	strb	r2, [r3, #8]
            enable_slave_if_required(this_i2c);
2000146c:	6878      	ldr	r0, [r7, #4]
2000146e:	f7ff fd3f 	bl	20000ef0 <enable_slave_if_required>
            break;
20001472:	e1bb      	b.n	200017ec <mss_i2c_isr+0x8d4>
          
        case ST_RX_DATA_ACK: /* Data byte received, ACK returned */
            /* First, get the data */
            this_i2c->master_rx_buffer[this_i2c->master_rx_idx++] = this_i2c->hw_reg->DATA;
20001474:	687b      	ldr	r3, [r7, #4]
20001476:	6b1a      	ldr	r2, [r3, #48]	; 0x30
20001478:	687b      	ldr	r3, [r7, #4]
2000147a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000147c:	441a      	add	r2, r3
2000147e:	6879      	ldr	r1, [r7, #4]
20001480:	6949      	ldr	r1, [r1, #20]
20001482:	7a09      	ldrb	r1, [r1, #8]
20001484:	b2c9      	uxtb	r1, r1
20001486:	7011      	strb	r1, [r2, #0]
20001488:	f103 0201 	add.w	r2, r3, #1
2000148c:	687b      	ldr	r3, [r7, #4]
2000148e:	639a      	str	r2, [r3, #56]	; 0x38

            if( this_i2c->master_rx_idx >= (this_i2c->master_rx_size - 1u))
20001490:	687b      	ldr	r3, [r7, #4]
20001492:	6b9a      	ldr	r2, [r3, #56]	; 0x38
20001494:	687b      	ldr	r3, [r7, #4]
20001496:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20001498:	f103 33ff 	add.w	r3, r3, #4294967295
2000149c:	429a      	cmp	r2, r3
2000149e:	f0c0 819e 	bcc.w	200017de <mss_i2c_isr+0x8c6>
            {
                /* If we're at the second last byte, let's set AA to 0 so
                 * we return a NACK at the last byte. */
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
200014a2:	687b      	ldr	r3, [r7, #4]
200014a4:	699b      	ldr	r3, [r3, #24]
200014a6:	f04f 0200 	mov.w	r2, #0
200014aa:	609a      	str	r2, [r3, #8]
            }
            break;
200014ac:	e19e      	b.n	200017ec <mss_i2c_isr+0x8d4>
            
        case ST_RX_DATA_NACK: /* Data byte received, NACK returned */
            /* Get the data, then send a stop condition */
            this_i2c->master_rx_buffer[this_i2c->master_rx_idx] = this_i2c->hw_reg->DATA;
200014ae:	687b      	ldr	r3, [r7, #4]
200014b0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
200014b2:	687b      	ldr	r3, [r7, #4]
200014b4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200014b6:	4413      	add	r3, r2
200014b8:	687a      	ldr	r2, [r7, #4]
200014ba:	6952      	ldr	r2, [r2, #20]
200014bc:	7a12      	ldrb	r2, [r2, #8]
200014be:	b2d2      	uxtb	r2, r2
200014c0:	701a      	strb	r2, [r3, #0]
          
            hold_bus = this_i2c->options &  MSS_I2C_HOLD_BUS; 
200014c2:	687b      	ldr	r3, [r7, #4]
200014c4:	7c1b      	ldrb	r3, [r3, #16]
200014c6:	f003 0301 	and.w	r3, r3, #1
200014ca:	737b      	strb	r3, [r7, #13]

            /* Store the information of current I2C bus status in the bus_status*/
            this_i2c->bus_status  = hold_bus;
200014cc:	687b      	ldr	r3, [r7, #4]
200014ce:	7b7a      	ldrb	r2, [r7, #13]
200014d0:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
            if ( hold_bus == 0u )
200014d4:	7b7b      	ldrb	r3, [r7, #13]
200014d6:	2b00      	cmp	r3, #0
200014d8:	d108      	bne.n	200014ec <mss_i2c_isr+0x5d4>
            { 
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;  /*xmt stop condition */
200014da:	687b      	ldr	r3, [r7, #4]
200014dc:	699b      	ldr	r3, [r3, #24]
200014de:	f04f 0201 	mov.w	r2, #1
200014e2:	611a      	str	r2, [r3, #16]

                /* Bus is released, now we can start listening to bus, if it is slave */
                   enable_slave_if_required(this_i2c);
200014e4:	6878      	ldr	r0, [r7, #4]
200014e6:	f7ff fd03 	bl	20000ef0 <enable_slave_if_required>
200014ea:	e008      	b.n	200014fe <mss_i2c_isr+0x5e6>
            }
            else
            {
                NVIC_DisableIRQ( this_i2c->irqn );
200014ec:	687b      	ldr	r3, [r7, #4]
200014ee:	7c5b      	ldrb	r3, [r3, #17]
200014f0:	b25b      	sxtb	r3, r3
200014f2:	4618      	mov	r0, r3
200014f4:	f7ff fcde 	bl	20000eb4 <NVIC_DisableIRQ>
                clear_irq = 0u;
200014f8:	f04f 0300 	mov.w	r3, #0
200014fc:	73bb      	strb	r3, [r7, #14]

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
200014fe:	687b      	ldr	r3, [r7, #4]
20001500:	f04f 0200 	mov.w	r2, #0
20001504:	721a      	strb	r2, [r3, #8]
            this_i2c->master_status = MSS_I2C_SUCCESS;
20001506:	687b      	ldr	r3, [r7, #4]
20001508:	f04f 0200 	mov.w	r2, #0
2000150c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            break;
20001510:	e16c      	b.n	200017ec <mss_i2c_isr+0x8d4>
        
        /******************** SLAVE RECEIVER **************************/
        case ST_GCA_NACK: /* NACK after, GCA addressing */
        case ST_SLA_NACK: /* Re-enable AA (assert ack) bit for future transmissions */
            this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
20001512:	687b      	ldr	r3, [r7, #4]
20001514:	699b      	ldr	r3, [r3, #24]
20001516:	f04f 0201 	mov.w	r2, #1
2000151a:	609a      	str	r2, [r3, #8]
            
            this_i2c->transaction = NO_TRANSACTION;
2000151c:	687b      	ldr	r3, [r7, #4]
2000151e:	f04f 0200 	mov.w	r2, #0
20001522:	721a      	strb	r2, [r3, #8]
            this_i2c->slave_status = MSS_I2C_SUCCESS;
20001524:	687b      	ldr	r3, [r7, #4]
20001526:	f04f 0200 	mov.w	r2, #0
2000152a:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
            
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
2000152e:	687b      	ldr	r3, [r7, #4]
20001530:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
20001534:	2b00      	cmp	r3, #0
20001536:	f000 8154 	beq.w	200017e2 <mss_i2c_isr+0x8ca>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
2000153a:	687b      	ldr	r3, [r7, #4]
2000153c:	699b      	ldr	r3, [r3, #24]
2000153e:	f04f 0201 	mov.w	r2, #1
20001542:	615a      	str	r2, [r3, #20]
            }
            break;
20001544:	e152      	b.n	200017ec <mss_i2c_isr+0x8d4>
        case ST_SLV_LA: /* Arbitr. lost (SLA rec'd) */
            /*
             *  We lost arbitration and either the GCE or our address was the
             *  one received so pend the master operation we were starting.
             */
            this_i2c->is_transaction_pending = 1u;
20001546:	687b      	ldr	r3, [r7, #4]
20001548:	f04f 0201 	mov.w	r2, #1
2000154c:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
            /* Fall through to normal ST processing as we are now in slave mode */

        case ST_GCA: /* General call address received, ACK returned */
        case ST_SLAVE_SLAW: /* SLA+W received, ACK returned */

            this_i2c->transaction = WRITE_SLAVE_TRANSACTION;
20001550:	687b      	ldr	r3, [r7, #4]
20001552:	f04f 0204 	mov.w	r2, #4
20001556:	721a      	strb	r2, [r3, #8]
            this_i2c->slave_rx_idx = 0u;
20001558:	687b      	ldr	r3, [r7, #4]
2000155a:	f04f 0200 	mov.w	r2, #0
2000155e:	659a      	str	r2, [r3, #88]	; 0x58
            this_i2c->random_read_addr = 0u;
20001560:	687b      	ldr	r3, [r7, #4]
20001562:	f04f 0200 	mov.w	r2, #0
20001566:	60da      	str	r2, [r3, #12]

             /* If Start Bit is set, clear it, but store that information since it is because of
              * pending transaction
              */
            if(this_i2c->hw_reg_bit->CTRL_STA)
20001568:	687b      	ldr	r3, [r7, #4]
2000156a:	699b      	ldr	r3, [r3, #24]
2000156c:	695b      	ldr	r3, [r3, #20]
2000156e:	2b00      	cmp	r3, #0
20001570:	d009      	beq.n	20001586 <mss_i2c_isr+0x66e>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 0u ;
20001572:	687b      	ldr	r3, [r7, #4]
20001574:	699b      	ldr	r3, [r3, #24]
20001576:	f04f 0200 	mov.w	r2, #0
2000157a:	615a      	str	r2, [r3, #20]
                this_i2c->is_transaction_pending = 1u;
2000157c:	687b      	ldr	r3, [r7, #4]
2000157e:	f04f 0201 	mov.w	r2, #1
20001582:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
            }
            this_i2c->slave_status = MSS_I2C_IN_PROGRESS;
20001586:	687b      	ldr	r3, [r7, #4]
20001588:	f04f 0201 	mov.w	r2, #1
2000158c:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
#ifdef MSS_I2C_INCLUDE_SLA_IN_RX_PAYLOAD
            /* Fall through to put address as first byte in payload buffer */
#else
            /* Only break from this case if the slave address must NOT be included at the
             * beginning of the received write data. */
            break;
20001590:	e12c      	b.n	200017ec <mss_i2c_isr+0x8d4>
#endif            
        case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
        case ST_RDATA: /* DATA received; must clear DATA register */
            if((this_i2c->slave_rx_buffer != (uint8_t *)0)
20001592:	687b      	ldr	r3, [r7, #4]
20001594:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20001596:	2b00      	cmp	r3, #0
20001598:	d01c      	beq.n	200015d4 <mss_i2c_isr+0x6bc>
               && (this_i2c->slave_rx_idx < this_i2c->slave_rx_size))
2000159a:	687b      	ldr	r3, [r7, #4]
2000159c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
2000159e:	687b      	ldr	r3, [r7, #4]
200015a0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
             * beginning of the received write data. */
            break;
#endif            
        case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
        case ST_RDATA: /* DATA received; must clear DATA register */
            if((this_i2c->slave_rx_buffer != (uint8_t *)0)
200015a2:	429a      	cmp	r2, r3
200015a4:	d216      	bcs.n	200015d4 <mss_i2c_isr+0x6bc>
               && (this_i2c->slave_rx_idx < this_i2c->slave_rx_size))
            {
                data = this_i2c->hw_reg->DATA;
200015a6:	687b      	ldr	r3, [r7, #4]
200015a8:	695b      	ldr	r3, [r3, #20]
200015aa:	7a1b      	ldrb	r3, [r3, #8]
200015ac:	733b      	strb	r3, [r7, #12]
                this_i2c->slave_rx_buffer[this_i2c->slave_rx_idx++] = data;
200015ae:	687b      	ldr	r3, [r7, #4]
200015b0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
200015b2:	687b      	ldr	r3, [r7, #4]
200015b4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
200015b6:	441a      	add	r2, r3
200015b8:	7b39      	ldrb	r1, [r7, #12]
200015ba:	7011      	strb	r1, [r2, #0]
200015bc:	f103 0201 	add.w	r2, r3, #1
200015c0:	687b      	ldr	r3, [r7, #4]
200015c2:	659a      	str	r2, [r3, #88]	; 0x58
                {
                    /* Ignore the slave address byte in the random read address
                       computation in the case where INCLUDE_SLA_IN_RX_PAYLOAD
                       is defined. */
#endif
                    this_i2c->random_read_addr = (this_i2c->random_read_addr << 8) + data;
200015c4:	687b      	ldr	r3, [r7, #4]
200015c6:	68db      	ldr	r3, [r3, #12]
200015c8:	ea4f 2203 	mov.w	r2, r3, lsl #8
200015cc:	7b3b      	ldrb	r3, [r7, #12]
200015ce:	441a      	add	r2, r3
200015d0:	687b      	ldr	r3, [r7, #4]
200015d2:	60da      	str	r2, [r3, #12]
#ifdef MSS_I2C_INCLUDE_SLA_IN_RX_PAYLOAD
                }
#endif
            }
            
            if (this_i2c->slave_rx_idx >= this_i2c->slave_rx_size)
200015d4:	687b      	ldr	r3, [r7, #4]
200015d6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
200015d8:	687b      	ldr	r3, [r7, #4]
200015da:	6d5b      	ldr	r3, [r3, #84]	; 0x54
200015dc:	429a      	cmp	r2, r3
200015de:	f0c0 8102 	bcc.w	200017e6 <mss_i2c_isr+0x8ce>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;   /* send a NACK when done (next reception) */
200015e2:	687b      	ldr	r3, [r7, #4]
200015e4:	699b      	ldr	r3, [r3, #24]
200015e6:	f04f 0200 	mov.w	r2, #0
200015ea:	609a      	str	r2, [r3, #8]
            }
            break;
200015ec:	e0fe      	b.n	200017ec <mss_i2c_isr+0x8d4>
            /* STOP or repeated START occurred. */
            /* We cannot be sure if the transaction has actually completed as
             * this hardware state reports that either a STOP or repeated START
             * condition has occurred. We assume that this is a repeated START
             * if the transaction was a write from the master to this point.*/
            if ( this_i2c->transaction == WRITE_SLAVE_TRANSACTION )
200015ee:	687b      	ldr	r3, [r7, #4]
200015f0:	7a1b      	ldrb	r3, [r3, #8]
200015f2:	2b04      	cmp	r3, #4
200015f4:	d135      	bne.n	20001662 <mss_i2c_isr+0x74a>
            {
                if ( this_i2c->slave_rx_idx == this_i2c->slave_mem_offset_length )
200015f6:	687b      	ldr	r3, [r7, #4]
200015f8:	6d9a      	ldr	r2, [r3, #88]	; 0x58
200015fa:	687b      	ldr	r3, [r7, #4]
200015fc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
200015fe:	429a      	cmp	r2, r3
20001600:	d103      	bne.n	2000160a <mss_i2c_isr+0x6f2>
                {
                    this_i2c->slave_tx_idx = this_i2c->random_read_addr;
20001602:	687b      	ldr	r3, [r7, #4]
20001604:	68da      	ldr	r2, [r3, #12]
20001606:	687b      	ldr	r3, [r7, #4]
20001608:	64da      	str	r2, [r3, #76]	; 0x4c
                }
                {
                    /* Call the slave's write transaction handler if it exists. */
                    if ( this_i2c->slave_write_handler != 0u )
2000160a:	687b      	ldr	r3, [r7, #4]
2000160c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2000160e:	2b00      	cmp	r3, #0
20001610:	d021      	beq.n	20001656 <mss_i2c_isr+0x73e>
                    {
                        mss_i2c_slave_handler_ret_t h_ret;
                        h_ret = this_i2c->slave_write_handler( this_i2c, this_i2c->slave_rx_buffer, (uint16_t)this_i2c->slave_rx_idx );
20001612:	687b      	ldr	r3, [r7, #4]
20001614:	6e5b      	ldr	r3, [r3, #100]	; 0x64
20001616:	687a      	ldr	r2, [r7, #4]
20001618:	6d11      	ldr	r1, [r2, #80]	; 0x50
2000161a:	687a      	ldr	r2, [r7, #4]
2000161c:	6d92      	ldr	r2, [r2, #88]	; 0x58
2000161e:	b292      	uxth	r2, r2
20001620:	6878      	ldr	r0, [r7, #4]
20001622:	4798      	blx	r3
20001624:	4603      	mov	r3, r0
20001626:	73fb      	strb	r3, [r7, #15]
                        if ( MSS_I2C_REENABLE_SLAVE_RX == h_ret )
20001628:	7bfb      	ldrb	r3, [r7, #15]
2000162a:	2b00      	cmp	r3, #0
2000162c:	d108      	bne.n	20001640 <mss_i2c_isr+0x728>
                        {
                            /* There is a small risk that the write handler could
                             * call MSS_I2C_disable_slave() but return
                             * MSS_I2C_REENABLE_SLAVE_RX in error so we only
                             * enable ACKs if still in slave mode. */
                             enable_slave_if_required(this_i2c);
2000162e:	6878      	ldr	r0, [r7, #4]
20001630:	f7ff fc5e 	bl	20000ef0 <enable_slave_if_required>
                             this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
20001634:	687b      	ldr	r3, [r7, #4]
20001636:	699b      	ldr	r3, [r3, #24]
20001638:	f04f 0201 	mov.w	r2, #1
2000163c:	609a      	str	r2, [r3, #8]
                        }
                    }
                    else
                    {
                        /* Re-enable address acknowledge in case we were ready to nack the next received byte. */
                        this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
2000163e:	e017      	b.n	20001670 <mss_i2c_isr+0x758>
                             enable_slave_if_required(this_i2c);
                             this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
                        }
                        else
                        {
                            this_i2c->hw_reg_bit->CTRL_AA = 0u;
20001640:	687b      	ldr	r3, [r7, #4]
20001642:	699b      	ldr	r3, [r3, #24]
20001644:	f04f 0200 	mov.w	r2, #0
20001648:	609a      	str	r2, [r3, #8]
                            /* Clear slave mode flag as well otherwise in mixed
                             * master/slave applications, the AA bit will get set by
                             * subsequent master operations. */
                            this_i2c->is_slave_enabled = 0u;
2000164a:	687b      	ldr	r3, [r7, #4]
2000164c:	f04f 0200 	mov.w	r2, #0
20001650:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
                        }
                    }
                    else
                    {
                        /* Re-enable address acknowledge in case we were ready to nack the next received byte. */
                        this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
20001654:	e00c      	b.n	20001670 <mss_i2c_isr+0x758>
20001656:	687b      	ldr	r3, [r7, #4]
20001658:	699b      	ldr	r3, [r3, #24]
2000165a:	f04f 0201 	mov.w	r2, #1
2000165e:	609a      	str	r2, [r3, #8]
20001660:	e006      	b.n	20001670 <mss_i2c_isr+0x758>
            {
                /*
                 * Reset slave_tx_idx so that a subsequent read will result in the slave's
                 * transmit buffer being sent from the first byte.
                 */
                this_i2c->slave_tx_idx = 0u;
20001662:	687b      	ldr	r3, [r7, #4]
20001664:	f04f 0200 	mov.w	r2, #0
20001668:	64da      	str	r2, [r3, #76]	; 0x4c
                /*
                 * See if we need to re-enable acknowledgement as some error conditions, such
                 * as a master prematurely ending a transfer, can see us get here with AA set
                 * to 0 which will disable slave operation if we are not careful.
                 */
                enable_slave_if_required(this_i2c);
2000166a:	6878      	ldr	r0, [r7, #4]
2000166c:	f7ff fc40 	bl	20000ef0 <enable_slave_if_required>
            }

            /* Mark any previous master write transaction as complete. */
            this_i2c->slave_status = MSS_I2C_SUCCESS;
20001670:	687b      	ldr	r3, [r7, #4]
20001672:	f04f 0200 	mov.w	r2, #0
20001676:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
2000167a:	687b      	ldr	r3, [r7, #4]
2000167c:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
20001680:	2b00      	cmp	r3, #0
20001682:	d004      	beq.n	2000168e <mss_i2c_isr+0x776>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
20001684:	687b      	ldr	r3, [r7, #4]
20001686:	699b      	ldr	r3, [r3, #24]
20001688:	f04f 0201 	mov.w	r2, #1
2000168c:	615a      	str	r2, [r3, #20]

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
2000168e:	687b      	ldr	r3, [r7, #4]
20001690:	f04f 0200 	mov.w	r2, #0
20001694:	721a      	strb	r2, [r3, #8]
            break;
20001696:	e0a9      	b.n	200017ec <mss_i2c_isr+0x8d4>
        case ST_SLV_RST: /* SMBUS ONLY: timeout state. must clear interrupt */
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction.
             */
            this_i2c->transaction = NO_TRANSACTION;
20001698:	687b      	ldr	r3, [r7, #4]
2000169a:	f04f 0200 	mov.w	r2, #0
2000169e:	721a      	strb	r2, [r3, #8]
            /*
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte.
             */
            this_i2c->slave_tx_idx = 0u;
200016a0:	687b      	ldr	r3, [r7, #4]
200016a2:	f04f 0200 	mov.w	r2, #0
200016a6:	64da      	str	r2, [r3, #76]	; 0x4c
            /*
             * Clear status to I2C_FAILED only if there was an operation in progress.
             */
            if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
200016a8:	687b      	ldr	r3, [r7, #4]
200016aa:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
200016ae:	b2db      	uxtb	r3, r3
200016b0:	2b01      	cmp	r3, #1
200016b2:	d104      	bne.n	200016be <mss_i2c_isr+0x7a6>
            {
                this_i2c->slave_status = MSS_I2C_FAILED;
200016b4:	687b      	ldr	r3, [r7, #4]
200016b6:	f04f 0202 	mov.w	r2, #2
200016ba:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
            }

            enable_slave_if_required(this_i2c); /* Make sure AA is set correctly */
200016be:	6878      	ldr	r0, [r7, #4]
200016c0:	f7ff fc16 	bl	20000ef0 <enable_slave_if_required>

            break;
200016c4:	e092      	b.n	200017ec <mss_i2c_isr+0x8d4>
            
        /****************** SLAVE TRANSMITTER **************************/
        case ST_SLAVE_SLAR_ACK: /* SLA+R received, ACK returned */
        case ST_SLARW_LA:   /* Arbitration lost, SLA+R received, ACK returned */
        case ST_RACK: /* Data tx'ed, ACK received */
            if ( status == ST_SLAVE_SLAR_ACK )
200016c6:	7afb      	ldrb	r3, [r7, #11]
200016c8:	b2db      	uxtb	r3, r3
200016ca:	2ba8      	cmp	r3, #168	; 0xa8
200016cc:	d11b      	bne.n	20001706 <mss_i2c_isr+0x7ee>
            {
                this_i2c->transaction = READ_SLAVE_TRANSACTION;
200016ce:	687b      	ldr	r3, [r7, #4]
200016d0:	f04f 0205 	mov.w	r2, #5
200016d4:	721a      	strb	r2, [r3, #8]
                this_i2c->random_read_addr = 0u;
200016d6:	687b      	ldr	r3, [r7, #4]
200016d8:	f04f 0200 	mov.w	r2, #0
200016dc:	60da      	str	r2, [r3, #12]

                this_i2c->slave_status = MSS_I2C_IN_PROGRESS;
200016de:	687b      	ldr	r3, [r7, #4]
200016e0:	f04f 0201 	mov.w	r2, #1
200016e4:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

                /* If Start Bit is set, clear it, but store that information since it is because of
                 * pending transaction
                 */
                if(this_i2c->hw_reg_bit->CTRL_STA)
200016e8:	687b      	ldr	r3, [r7, #4]
200016ea:	699b      	ldr	r3, [r3, #24]
200016ec:	695b      	ldr	r3, [r3, #20]
200016ee:	2b00      	cmp	r3, #0
200016f0:	d009      	beq.n	20001706 <mss_i2c_isr+0x7ee>
                {
                    this_i2c->hw_reg_bit->CTRL_STA = 0u ;
200016f2:	687b      	ldr	r3, [r7, #4]
200016f4:	699b      	ldr	r3, [r3, #24]
200016f6:	f04f 0200 	mov.w	r2, #0
200016fa:	615a      	str	r2, [r3, #20]
                    this_i2c->is_transaction_pending = 1u;
200016fc:	687b      	ldr	r3, [r7, #4]
200016fe:	f04f 0201 	mov.w	r2, #1
20001702:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
                }
            }
            if (this_i2c->slave_tx_idx >= this_i2c->slave_tx_size)
20001706:	687b      	ldr	r3, [r7, #4]
20001708:	6cda      	ldr	r2, [r3, #76]	; 0x4c
2000170a:	687b      	ldr	r3, [r7, #4]
2000170c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2000170e:	429a      	cmp	r2, r3
20001710:	d305      	bcc.n	2000171e <mss_i2c_isr+0x806>
            {
                /* Ensure 0xFF is returned to the master when the slave specifies
                 * an empty transmit buffer. */
                this_i2c->hw_reg->DATA = 0xFFu;
20001712:	687b      	ldr	r3, [r7, #4]
20001714:	695b      	ldr	r3, [r3, #20]
20001716:	f04f 32ff 	mov.w	r2, #4294967295
2000171a:	721a      	strb	r2, [r3, #8]
2000171c:	e00c      	b.n	20001738 <mss_i2c_isr+0x820>
            }
            else
            {
                /* Load the data the data byte to be sent to the master. */
                this_i2c->hw_reg->DATA = this_i2c->slave_tx_buffer[this_i2c->slave_tx_idx++];
2000171e:	687b      	ldr	r3, [r7, #4]
20001720:	695a      	ldr	r2, [r3, #20]
20001722:	687b      	ldr	r3, [r7, #4]
20001724:	6c59      	ldr	r1, [r3, #68]	; 0x44
20001726:	687b      	ldr	r3, [r7, #4]
20001728:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2000172a:	4419      	add	r1, r3
2000172c:	7809      	ldrb	r1, [r1, #0]
2000172e:	7211      	strb	r1, [r2, #8]
20001730:	f103 0201 	add.w	r2, r3, #1
20001734:	687b      	ldr	r3, [r7, #4]
20001736:	64da      	str	r2, [r3, #76]	; 0x4c
            }
            /* Determine if this is the last data byte to send to the master. */
            if (this_i2c->slave_tx_idx >= this_i2c->slave_tx_size) /* last byte? */
20001738:	687b      	ldr	r3, [r7, #4]
2000173a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
2000173c:	687b      	ldr	r3, [r7, #4]
2000173e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20001740:	429a      	cmp	r2, r3
20001742:	d352      	bcc.n	200017ea <mss_i2c_isr+0x8d2>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
20001744:	687b      	ldr	r3, [r7, #4]
20001746:	699b      	ldr	r3, [r3, #24]
20001748:	f04f 0200 	mov.w	r2, #0
2000174c:	609a      	str	r2, [r3, #8]
                /* Next read transaction will result in slave's transmit buffer
                 * being sent from the first byte. */
                this_i2c->slave_tx_idx = 0u;
2000174e:	687b      	ldr	r3, [r7, #4]
20001750:	f04f 0200 	mov.w	r2, #0
20001754:	64da      	str	r2, [r3, #76]	; 0x4c
            }
            break;
20001756:	e049      	b.n	200017ec <mss_i2c_isr+0x8d4>
        case ST_SLAVE_RNACK:    /* Data byte has been transmitted; not-ACK has been received. */
        case ST_FINAL: /* Last Data byte tx'ed, ACK received */
            /* We assume that the transaction will be stopped by the master.
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte. */
            this_i2c->slave_tx_idx = 0u;
20001758:	687b      	ldr	r3, [r7, #4]
2000175a:	f04f 0200 	mov.w	r2, #0
2000175e:	64da      	str	r2, [r3, #76]	; 0x4c
            this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
20001760:	687b      	ldr	r3, [r7, #4]
20001762:	699b      	ldr	r3, [r3, #24]
20001764:	f04f 0201 	mov.w	r2, #1
20001768:	609a      	str	r2, [r3, #8]

            /*  Mark previous state as complete */
            this_i2c->slave_status = MSS_I2C_SUCCESS;
2000176a:	687b      	ldr	r3, [r7, #4]
2000176c:	f04f 0200 	mov.w	r2, #0
20001770:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
20001774:	687b      	ldr	r3, [r7, #4]
20001776:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
2000177a:	2b00      	cmp	r3, #0
2000177c:	d004      	beq.n	20001788 <mss_i2c_isr+0x870>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
2000177e:	687b      	ldr	r3, [r7, #4]
20001780:	699b      	ldr	r3, [r3, #24]
20001782:	f04f 0201 	mov.w	r2, #1
20001786:	615a      	str	r2, [r3, #20]

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
20001788:	687b      	ldr	r3, [r7, #4]
2000178a:	f04f 0200 	mov.w	r2, #0
2000178e:	721a      	strb	r2, [r3, #8]
            break;
20001790:	e02c      	b.n	200017ec <mss_i2c_isr+0x8d4>
        case ST_RESET_ACTIVATED:
        case ST_BUS_ERROR: /* Bus error during MST or selected slave modes */
        default:
            /* Some undefined state has encountered. Clear Start bit to make
             * sure, next good transaction happen */
            this_i2c->hw_reg_bit->CTRL_STA = 0x00u;
20001792:	687b      	ldr	r3, [r7, #4]
20001794:	699b      	ldr	r3, [r3, #24]
20001796:	f04f 0200 	mov.w	r2, #0
2000179a:	615a      	str	r2, [r3, #20]
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
2000179c:	687b      	ldr	r3, [r7, #4]
2000179e:	f04f 0200 	mov.w	r2, #0
200017a2:	721a      	strb	r2, [r3, #8]
            /*
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte.
             */
            this_i2c->slave_tx_idx = 0u;
200017a4:	687b      	ldr	r3, [r7, #4]
200017a6:	f04f 0200 	mov.w	r2, #0
200017aa:	64da      	str	r2, [r3, #76]	; 0x4c
            /*
             * Clear statuses to I2C_FAILED only if there was an operation in progress.
             */
            if(MSS_I2C_IN_PROGRESS == this_i2c->master_status)
200017ac:	687b      	ldr	r3, [r7, #4]
200017ae:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
200017b2:	b2db      	uxtb	r3, r3
200017b4:	2b01      	cmp	r3, #1
200017b6:	d104      	bne.n	200017c2 <mss_i2c_isr+0x8aa>
            {
                this_i2c->master_status = MSS_I2C_FAILED;
200017b8:	687b      	ldr	r3, [r7, #4]
200017ba:	f04f 0202 	mov.w	r2, #2
200017be:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            }

            if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
200017c2:	687b      	ldr	r3, [r7, #4]
200017c4:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
200017c8:	b2db      	uxtb	r3, r3
200017ca:	2b01      	cmp	r3, #1
200017cc:	d10e      	bne.n	200017ec <mss_i2c_isr+0x8d4>
            {
                this_i2c->slave_status = MSS_I2C_FAILED;
200017ce:	687b      	ldr	r3, [r7, #4]
200017d0:	f04f 0202 	mov.w	r2, #2
200017d4:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
200017d8:	e008      	b.n	200017ec <mss_i2c_isr+0x8d4>
             */
            if(this_i2c->transaction != this_i2c->pending_transaction)
            {
                this_i2c->transaction = this_i2c->pending_transaction;
            }
            break;
200017da:	bf00      	nop
200017dc:	e006      	b.n	200017ec <mss_i2c_isr+0x8d4>
            {
                /* If we're at the second last byte, let's set AA to 0 so
                 * we return a NACK at the last byte. */
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
            }
            break;
200017de:	bf00      	nop
200017e0:	e004      	b.n	200017ec <mss_i2c_isr+0x8d4>
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
            }
            break;
200017e2:	bf00      	nop
200017e4:	e002      	b.n	200017ec <mss_i2c_isr+0x8d4>
            
            if (this_i2c->slave_rx_idx >= this_i2c->slave_rx_size)
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;   /* send a NACK when done (next reception) */
            }
            break;
200017e6:	bf00      	nop
200017e8:	e000      	b.n	200017ec <mss_i2c_isr+0x8d4>
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
                /* Next read transaction will result in slave's transmit buffer
                 * being sent from the first byte. */
                this_i2c->slave_tx_idx = 0u;
            }
            break;
200017ea:	bf00      	nop


            break;
    }
    
    if ( clear_irq )
200017ec:	7bbb      	ldrb	r3, [r7, #14]
200017ee:	2b00      	cmp	r3, #0
200017f0:	d004      	beq.n	200017fc <mss_i2c_isr+0x8e4>
    {
        /* clear interrupt. */
        this_i2c->hw_reg_bit->CTRL_SI = 0u;
200017f2:	687b      	ldr	r3, [r7, #4]
200017f4:	699b      	ldr	r3, [r3, #24]
200017f6:	f04f 0200 	mov.w	r2, #0
200017fa:	60da      	str	r2, [r3, #12]
    }
    
    /* Read the status register to ensure the last I2C registers write took place
     * in a system built around a bus making use of posted writes. */
    status = this_i2c->hw_reg->STATUS;
200017fc:	687b      	ldr	r3, [r7, #4]
200017fe:	695b      	ldr	r3, [r3, #20]
20001800:	791b      	ldrb	r3, [r3, #4]
20001802:	72fb      	strb	r3, [r7, #11]
}
20001804:	f107 0710 	add.w	r7, r7, #16
20001808:	46bd      	mov	sp, r7
2000180a:	bd80      	pop	{r7, pc}

2000180c <I2C0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void I2C0_IRQHandler( void )
#else
void I2C0_IRQHandler( void )
#endif
{
2000180c:	4668      	mov	r0, sp
2000180e:	f020 0107 	bic.w	r1, r0, #7
20001812:	468d      	mov	sp, r1
20001814:	b589      	push	{r0, r3, r7, lr}
20001816:	af00      	add	r7, sp, #0
    mss_i2c_isr( &g_mss_i2c0 );
20001818:	f243 3040 	movw	r0, #13120	; 0x3340
2000181c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001820:	f7ff fb7a 	bl	20000f18 <mss_i2c_isr>
}
20001824:	46bd      	mov	sp, r7
20001826:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
2000182a:	4685      	mov	sp, r0
2000182c:	4770      	bx	lr
2000182e:	bf00      	nop

20001830 <I2C1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void I2C1_IRQHandler( void )
#else
void I2C1_IRQHandler( void )
#endif
{
20001830:	4668      	mov	r0, sp
20001832:	f020 0107 	bic.w	r1, r0, #7
20001836:	468d      	mov	sp, r1
20001838:	b589      	push	{r0, r3, r7, lr}
2000183a:	af00      	add	r7, sp, #0
    mss_i2c_isr( &g_mss_i2c1 );
2000183c:	f243 30b4 	movw	r0, #13236	; 0x33b4
20001840:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001844:	f7ff fb68 	bl	20000f18 <mss_i2c_isr>
}
20001848:	46bd      	mov	sp, r7
2000184a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
2000184e:	4685      	mov	sp, r0
20001850:	4770      	bx	lr
20001852:	bf00      	nop

20001854 <I2C_init>:
    i2c_instance_t * this_i2c,
    addr_t base_address,
    uint8_t ser_address,
    i2c_clock_divider_t ser_clock_speed
)
{
20001854:	b580      	push	{r7, lr}
20001856:	b086      	sub	sp, #24
20001858:	af00      	add	r7, sp, #0
2000185a:	60f8      	str	r0, [r7, #12]
2000185c:	60b9      	str	r1, [r7, #8]
2000185e:	71fa      	strb	r2, [r7, #7]
20001860:	71bb      	strb	r3, [r7, #6]
    psr_t saved_psr;
    uint_fast16_t clock_speed = (uint_fast16_t)ser_clock_speed;
20001862:	79bb      	ldrb	r3, [r7, #6]
20001864:	617b      	str	r3, [r7, #20]
    
    /*
     * We need to disable ints while doing this as there is no guarantee we
     * have not been called already and the ISR is active.
     */
    saved_psr = HAL_disable_interrupts();
20001866:	f001 f853 	bl	20002910 <HAL_disable_interrupts>
2000186a:	4603      	mov	r3, r0
2000186c:	613b      	str	r3, [r7, #16]
     * Initialize all items of the this_i2c data structure to zero. This
     * initializes all state variables to their init value. It relies on
     * the fact that NO_TRANSACTION, I2C_SUCCESS and I2C_RELEASE_BUS all
     * have an actual value of zero.
     */
    memset(this_i2c, 0, sizeof(i2c_instance_t));
2000186e:	68f8      	ldr	r0, [r7, #12]
20001870:	f04f 0100 	mov.w	r1, #0
20001874:	f04f 026c 	mov.w	r2, #108	; 0x6c
20001878:	f001 f8c2 	bl	20002a00 <memset>
    
    /*
     * Set base address of I2C hardware used by this instance.
     */
    this_i2c->base_address = base_address;
2000187c:	68fb      	ldr	r3, [r7, #12]
2000187e:	68ba      	ldr	r2, [r7, #8]
20001880:	601a      	str	r2, [r3, #0]

    /*
     * Update Serial address of the device
     */
    this_i2c->ser_address = ((uint_fast8_t)ser_address << 1u);
20001882:	79fb      	ldrb	r3, [r7, #7]
20001884:	ea4f 0243 	mov.w	r2, r3, lsl #1
20001888:	68fb      	ldr	r3, [r7, #12]
2000188a:	605a      	str	r2, [r3, #4]
    
    /*
     * Configure hardware.
     */
    HAL_set_8bit_reg_field(this_i2c->base_address, ENS1, 0x00); /* Reset I2C hardware. */
2000188c:	68fb      	ldr	r3, [r7, #12]
2000188e:	681b      	ldr	r3, [r3, #0]
20001890:	4618      	mov	r0, r3
20001892:	f04f 0106 	mov.w	r1, #6
20001896:	f04f 0240 	mov.w	r2, #64	; 0x40
2000189a:	f04f 0300 	mov.w	r3, #0
2000189e:	f001 f872 	bl	20002986 <HW_set_8bit_reg_field>
    HAL_set_8bit_reg_field(this_i2c->base_address, ENS1, 0x01); /* set enable bit */
200018a2:	68fb      	ldr	r3, [r7, #12]
200018a4:	681b      	ldr	r3, [r3, #0]
200018a6:	4618      	mov	r0, r3
200018a8:	f04f 0106 	mov.w	r1, #6
200018ac:	f04f 0240 	mov.w	r2, #64	; 0x40
200018b0:	f04f 0301 	mov.w	r3, #1
200018b4:	f001 f867 	bl	20002986 <HW_set_8bit_reg_field>
    HAL_set_8bit_reg_field(this_i2c->base_address, CR2, ( (clock_speed >> 2) & 0x01) );
200018b8:	68fb      	ldr	r3, [r7, #12]
200018ba:	681a      	ldr	r2, [r3, #0]
200018bc:	697b      	ldr	r3, [r7, #20]
200018be:	ea4f 0393 	mov.w	r3, r3, lsr #2
200018c2:	f003 0301 	and.w	r3, r3, #1
200018c6:	4610      	mov	r0, r2
200018c8:	f04f 0107 	mov.w	r1, #7
200018cc:	f04f 0280 	mov.w	r2, #128	; 0x80
200018d0:	f001 f859 	bl	20002986 <HW_set_8bit_reg_field>
    HAL_set_8bit_reg_field(this_i2c->base_address, CR1, ( (clock_speed >> 1) & 0x01) );
200018d4:	68fb      	ldr	r3, [r7, #12]
200018d6:	681a      	ldr	r2, [r3, #0]
200018d8:	697b      	ldr	r3, [r7, #20]
200018da:	ea4f 0353 	mov.w	r3, r3, lsr #1
200018de:	f003 0301 	and.w	r3, r3, #1
200018e2:	4610      	mov	r0, r2
200018e4:	f04f 0101 	mov.w	r1, #1
200018e8:	f04f 0202 	mov.w	r2, #2
200018ec:	f001 f84b 	bl	20002986 <HW_set_8bit_reg_field>
    HAL_set_8bit_reg_field(this_i2c->base_address, CR0, ( clock_speed & 0x01) );
200018f0:	68fb      	ldr	r3, [r7, #12]
200018f2:	681a      	ldr	r2, [r3, #0]
200018f4:	697b      	ldr	r3, [r7, #20]
200018f6:	f003 0301 	and.w	r3, r3, #1
200018fa:	4610      	mov	r0, r2
200018fc:	f04f 0100 	mov.w	r1, #0
20001900:	f04f 0201 	mov.w	r2, #1
20001904:	f001 f83f 	bl	20002986 <HW_set_8bit_reg_field>

    HAL_set_8bit_reg(this_i2c->base_address, ADDRESS, this_i2c->ser_address);
20001908:	68fb      	ldr	r3, [r7, #12]
2000190a:	681b      	ldr	r3, [r3, #0]
2000190c:	f103 020c 	add.w	r2, r3, #12
20001910:	68fb      	ldr	r3, [r7, #12]
20001912:	685b      	ldr	r3, [r3, #4]
20001914:	4610      	mov	r0, r2
20001916:	4619      	mov	r1, r3
20001918:	f001 f831 	bl	2000297e <HW_set_8bit_reg>
    HAL_set_8bit_reg(this_i2c->base_address, ADDRESS1, this_i2c->ser_address);
2000191c:	68fb      	ldr	r3, [r7, #12]
2000191e:	681b      	ldr	r3, [r3, #0]
20001920:	f103 021c 	add.w	r2, r3, #28
20001924:	68fb      	ldr	r3, [r7, #12]
20001926:	685b      	ldr	r3, [r3, #4]
20001928:	4610      	mov	r0, r2
2000192a:	4619      	mov	r1, r3
2000192c:	f001 f827 	bl	2000297e <HW_set_8bit_reg>
    
    /*
     * Finally safe to enable interrupts.
     */
    HAL_restore_interrupts( saved_psr );
20001930:	6938      	ldr	r0, [r7, #16]
20001932:	f000 fff1 	bl	20002918 <HAL_restore_interrupts>
}
20001936:	f107 0718 	add.w	r7, r7, #24
2000193a:	46bd      	mov	sp, r7
2000193c:	bd80      	pop	{r7, pc}
2000193e:	bf00      	nop

20001940 <I2C_write>:
    uint8_t serial_addr,
    const uint8_t * write_buffer,
    uint16_t write_size,
    uint8_t options
)
{
20001940:	b580      	push	{r7, lr}
20001942:	b086      	sub	sp, #24
20001944:	af00      	add	r7, sp, #0
20001946:	60f8      	str	r0, [r7, #12]
20001948:	607a      	str	r2, [r7, #4]
2000194a:	460a      	mov	r2, r1
2000194c:	72fa      	strb	r2, [r7, #11]
2000194e:	807b      	strh	r3, [r7, #2]
    psr_t saved_psr;
    volatile uint8_t stat_ctrl;

    saved_psr = HAL_disable_interrupts();
20001950:	f000 ffde 	bl	20002910 <HAL_disable_interrupts>
20001954:	4603      	mov	r3, r0
20001956:	617b      	str	r3, [r7, #20]

    /* Update the transaction only when there is no transaction going on I2C */
    if( this_i2c->transaction == NO_TRANSACTION)
20001958:	68fb      	ldr	r3, [r7, #12]
2000195a:	7b1b      	ldrb	r3, [r3, #12]
2000195c:	2b00      	cmp	r3, #0
2000195e:	d103      	bne.n	20001968 <I2C_write+0x28>
    {
      this_i2c->transaction = MASTER_WRITE_TRANSACTION;
20001960:	68fb      	ldr	r3, [r7, #12]
20001962:	f04f 0201 	mov.w	r2, #1
20001966:	731a      	strb	r2, [r3, #12]
    }

    /* Update the Pending transaction information so that transaction can restarted */
    this_i2c->pending_transaction = MASTER_WRITE_TRANSACTION ;
20001968:	68fb      	ldr	r3, [r7, #12]
2000196a:	f04f 0201 	mov.w	r2, #1
2000196e:	f883 206a 	strb.w	r2, [r3, #106]	; 0x6a

    /* Update target address */
    this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
20001972:	7afb      	ldrb	r3, [r7, #11]
20001974:	ea4f 0243 	mov.w	r2, r3, lsl #1
20001978:	68fb      	ldr	r3, [r7, #12]
2000197a:	609a      	str	r2, [r3, #8]
    this_i2c->dir = WRITE_DIR;
2000197c:	68fb      	ldr	r3, [r7, #12]
2000197e:	f04f 0200 	mov.w	r2, #0
20001982:	625a      	str	r2, [r3, #36]	; 0x24
    this_i2c->master_tx_buffer = write_buffer;
20001984:	68fb      	ldr	r3, [r7, #12]
20001986:	687a      	ldr	r2, [r7, #4]
20001988:	619a      	str	r2, [r3, #24]
    this_i2c->master_tx_size = write_size;
2000198a:	887a      	ldrh	r2, [r7, #2]
2000198c:	68fb      	ldr	r3, [r7, #12]
2000198e:	61da      	str	r2, [r3, #28]
    this_i2c->master_tx_idx = 0u;
20001990:	68fb      	ldr	r3, [r7, #12]
20001992:	f04f 0200 	mov.w	r2, #0
20001996:	621a      	str	r2, [r3, #32]

    /* Set I2C status in progress */
    this_i2c->master_status = I2C_IN_PROGRESS;
20001998:	68fb      	ldr	r3, [r7, #12]
2000199a:	f04f 0201 	mov.w	r2, #1
2000199e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    this_i2c->options = options;
200019a2:	68fb      	ldr	r3, [r7, #12]
200019a4:	f897 2020 	ldrb.w	r2, [r7, #32]
200019a8:	751a      	strb	r2, [r3, #20]

    if(I2C_IN_PROGRESS == this_i2c->slave_status)
200019aa:	68fb      	ldr	r3, [r7, #12]
200019ac:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
200019b0:	b2db      	uxtb	r3, r3
200019b2:	2b01      	cmp	r3, #1
200019b4:	d105      	bne.n	200019c2 <I2C_write+0x82>
    {
        this_i2c->is_transaction_pending = 1u;
200019b6:	68fb      	ldr	r3, [r7, #12]
200019b8:	f04f 0201 	mov.w	r2, #1
200019bc:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
200019c0:	e00a      	b.n	200019d8 <I2C_write+0x98>
    }
    else
    {
        HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
200019c2:	68fb      	ldr	r3, [r7, #12]
200019c4:	681b      	ldr	r3, [r3, #0]
200019c6:	4618      	mov	r0, r3
200019c8:	f04f 0105 	mov.w	r1, #5
200019cc:	f04f 0220 	mov.w	r2, #32
200019d0:	f04f 0301 	mov.w	r3, #1
200019d4:	f000 ffd7 	bl	20002986 <HW_set_8bit_reg_field>
    /*
     * Clear interrupts if required (depends on repeated starts).
     * Since the Bus is on hold, only then prior status needs to
     * be cleared.
     */
    if ( I2C_HOLD_BUS == this_i2c->bus_status )
200019d8:	68fb      	ldr	r3, [r7, #12]
200019da:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
200019de:	2b01      	cmp	r3, #1
200019e0:	d10a      	bne.n	200019f8 <I2C_write+0xb8>
    {
        HAL_set_8bit_reg_field(this_i2c->base_address, SI, 0x00u);
200019e2:	68fb      	ldr	r3, [r7, #12]
200019e4:	681b      	ldr	r3, [r3, #0]
200019e6:	4618      	mov	r0, r3
200019e8:	f04f 0103 	mov.w	r1, #3
200019ec:	f04f 0208 	mov.w	r2, #8
200019f0:	f04f 0300 	mov.w	r3, #0
200019f4:	f000 ffc7 	bl	20002986 <HW_set_8bit_reg_field>
    }

    stat_ctrl = HAL_get_8bit_reg( this_i2c->base_address, STATUS);
200019f8:	68fb      	ldr	r3, [r7, #12]
200019fa:	681b      	ldr	r3, [r3, #0]
200019fc:	f103 0304 	add.w	r3, r3, #4
20001a00:	4618      	mov	r0, r3
20001a02:	f000 ffbe 	bl	20002982 <HW_get_8bit_reg>
20001a06:	4603      	mov	r3, r0
20001a08:	74fb      	strb	r3, [r7, #19]
    stat_ctrl = stat_ctrl;  /* Avoids lint warning. */
20001a0a:	7cfb      	ldrb	r3, [r7, #19]
20001a0c:	b2db      	uxtb	r3, r3
20001a0e:	74fb      	strb	r3, [r7, #19]

    /* Enable the interrupt. ( Re-enable) */
    I2C_enable_irq( this_i2c );
20001a10:	68f8      	ldr	r0, [r7, #12]
20001a12:	f000 fe31 	bl	20002678 <I2C_enable_irq>

    HAL_restore_interrupts( saved_psr );
20001a16:	6978      	ldr	r0, [r7, #20]
20001a18:	f000 ff7e 	bl	20002918 <HAL_restore_interrupts>
}
20001a1c:	f107 0718 	add.w	r7, r7, #24
20001a20:	46bd      	mov	sp, r7
20001a22:	bd80      	pop	{r7, pc}

20001a24 <I2C_read>:
    uint8_t serial_addr,
    uint8_t * read_buffer,
    uint16_t read_size,
    uint8_t options
)
{
20001a24:	b580      	push	{r7, lr}
20001a26:	b086      	sub	sp, #24
20001a28:	af00      	add	r7, sp, #0
20001a2a:	60f8      	str	r0, [r7, #12]
20001a2c:	607a      	str	r2, [r7, #4]
20001a2e:	460a      	mov	r2, r1
20001a30:	72fa      	strb	r2, [r7, #11]
20001a32:	807b      	strh	r3, [r7, #2]
    psr_t saved_psr;
    volatile uint8_t stat_ctrl;

    saved_psr = HAL_disable_interrupts();
20001a34:	f000 ff6c 	bl	20002910 <HAL_disable_interrupts>
20001a38:	4603      	mov	r3, r0
20001a3a:	617b      	str	r3, [r7, #20]
    
    /* Update the transaction only when there is no transaction going on I2C */
    if( this_i2c->transaction == NO_TRANSACTION)
20001a3c:	68fb      	ldr	r3, [r7, #12]
20001a3e:	7b1b      	ldrb	r3, [r3, #12]
20001a40:	2b00      	cmp	r3, #0
20001a42:	d103      	bne.n	20001a4c <I2C_read+0x28>
    {
      this_i2c->transaction = MASTER_READ_TRANSACTION;
20001a44:	68fb      	ldr	r3, [r7, #12]
20001a46:	f04f 0202 	mov.w	r2, #2
20001a4a:	731a      	strb	r2, [r3, #12]
    }

    /* Update the Pending transaction information so that transaction can restarted */
    this_i2c->pending_transaction = MASTER_READ_TRANSACTION ;
20001a4c:	68fb      	ldr	r3, [r7, #12]
20001a4e:	f04f 0202 	mov.w	r2, #2
20001a52:	f883 206a 	strb.w	r2, [r3, #106]	; 0x6a

    /* Update target address */
    this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
20001a56:	7afb      	ldrb	r3, [r7, #11]
20001a58:	ea4f 0243 	mov.w	r2, r3, lsl #1
20001a5c:	68fb      	ldr	r3, [r7, #12]
20001a5e:	609a      	str	r2, [r3, #8]

    this_i2c->dir = READ_DIR;
20001a60:	68fb      	ldr	r3, [r7, #12]
20001a62:	f04f 0201 	mov.w	r2, #1
20001a66:	625a      	str	r2, [r3, #36]	; 0x24

    this_i2c->master_rx_buffer = read_buffer;
20001a68:	68fb      	ldr	r3, [r7, #12]
20001a6a:	687a      	ldr	r2, [r7, #4]
20001a6c:	629a      	str	r2, [r3, #40]	; 0x28
    this_i2c->master_rx_size = read_size;
20001a6e:	887a      	ldrh	r2, [r7, #2]
20001a70:	68fb      	ldr	r3, [r7, #12]
20001a72:	62da      	str	r2, [r3, #44]	; 0x2c
    this_i2c->master_rx_idx = 0u;
20001a74:	68fb      	ldr	r3, [r7, #12]
20001a76:	f04f 0200 	mov.w	r2, #0
20001a7a:	631a      	str	r2, [r3, #48]	; 0x30

    /* Set I2C status in progress */
    this_i2c->master_status = I2C_IN_PROGRESS;
20001a7c:	68fb      	ldr	r3, [r7, #12]
20001a7e:	f04f 0201 	mov.w	r2, #1
20001a82:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    this_i2c->options = options;
20001a86:	68fb      	ldr	r3, [r7, #12]
20001a88:	f897 2020 	ldrb.w	r2, [r7, #32]
20001a8c:	751a      	strb	r2, [r3, #20]
    
    if(I2C_IN_PROGRESS == this_i2c->slave_status)
20001a8e:	68fb      	ldr	r3, [r7, #12]
20001a90:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
20001a94:	b2db      	uxtb	r3, r3
20001a96:	2b01      	cmp	r3, #1
20001a98:	d105      	bne.n	20001aa6 <I2C_read+0x82>
    {
        this_i2c->is_transaction_pending = 1u;
20001a9a:	68fb      	ldr	r3, [r7, #12]
20001a9c:	f04f 0201 	mov.w	r2, #1
20001aa0:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
20001aa4:	e00a      	b.n	20001abc <I2C_read+0x98>
    }
    else
    {
        HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
20001aa6:	68fb      	ldr	r3, [r7, #12]
20001aa8:	681b      	ldr	r3, [r3, #0]
20001aaa:	4618      	mov	r0, r3
20001aac:	f04f 0105 	mov.w	r1, #5
20001ab0:	f04f 0220 	mov.w	r2, #32
20001ab4:	f04f 0301 	mov.w	r3, #1
20001ab8:	f000 ff65 	bl	20002986 <HW_set_8bit_reg_field>
    /*
     * Clear interrupts if required (depends on repeated starts).
     * Since the Bus is on hold, only then prior status needs to
     * be cleared.
     */
    if ( I2C_HOLD_BUS == this_i2c->bus_status )
20001abc:	68fb      	ldr	r3, [r7, #12]
20001abe:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
20001ac2:	2b01      	cmp	r3, #1
20001ac4:	d10a      	bne.n	20001adc <I2C_read+0xb8>
    {
        HAL_set_8bit_reg_field(this_i2c->base_address, SI, 0x00u);
20001ac6:	68fb      	ldr	r3, [r7, #12]
20001ac8:	681b      	ldr	r3, [r3, #0]
20001aca:	4618      	mov	r0, r3
20001acc:	f04f 0103 	mov.w	r1, #3
20001ad0:	f04f 0208 	mov.w	r2, #8
20001ad4:	f04f 0300 	mov.w	r3, #0
20001ad8:	f000 ff55 	bl	20002986 <HW_set_8bit_reg_field>
    }

    stat_ctrl = HAL_get_8bit_reg( this_i2c->base_address, STATUS);
20001adc:	68fb      	ldr	r3, [r7, #12]
20001ade:	681b      	ldr	r3, [r3, #0]
20001ae0:	f103 0304 	add.w	r3, r3, #4
20001ae4:	4618      	mov	r0, r3
20001ae6:	f000 ff4c 	bl	20002982 <HW_get_8bit_reg>
20001aea:	4603      	mov	r3, r0
20001aec:	74fb      	strb	r3, [r7, #19]
    stat_ctrl = stat_ctrl;  /* Avoids lint warning. */
20001aee:	7cfb      	ldrb	r3, [r7, #19]
20001af0:	b2db      	uxtb	r3, r3
20001af2:	74fb      	strb	r3, [r7, #19]

    /* Enable the interrupt. ( Re-enable) */
    I2C_enable_irq( this_i2c );
20001af4:	68f8      	ldr	r0, [r7, #12]
20001af6:	f000 fdbf 	bl	20002678 <I2C_enable_irq>
    HAL_restore_interrupts( saved_psr );
20001afa:	6978      	ldr	r0, [r7, #20]
20001afc:	f000 ff0c 	bl	20002918 <HAL_restore_interrupts>
}
20001b00:	f107 0718 	add.w	r7, r7, #24
20001b04:	46bd      	mov	sp, r7
20001b06:	bd80      	pop	{r7, pc}

20001b08 <I2C_wait_complete>:
i2c_status_t I2C_wait_complete
(
    i2c_instance_t * this_i2c,
    uint32_t timeout_ms
)
{
20001b08:	b580      	push	{r7, lr}
20001b0a:	b084      	sub	sp, #16
20001b0c:	af00      	add	r7, sp, #0
20001b0e:	6078      	str	r0, [r7, #4]
20001b10:	6039      	str	r1, [r7, #0]
     * Because we have no idea of what CPU we are supposed to be running on
     * we need to guard this write to the timeout value to avoid ISR/user code
     * interaction issues. Checking the status below should be fine as only a
     * single byte should change in that.
     */
    saved_psr = HAL_disable_interrupts();
20001b12:	f000 fefd 	bl	20002910 <HAL_disable_interrupts>
20001b16:	4603      	mov	r3, r0
20001b18:	60fb      	str	r3, [r7, #12]
    this_i2c->master_timeout_ms = timeout_ms;
20001b1a:	687b      	ldr	r3, [r7, #4]
20001b1c:	683a      	ldr	r2, [r7, #0]
20001b1e:	639a      	str	r2, [r3, #56]	; 0x38
    HAL_restore_interrupts( saved_psr );
20001b20:	68f8      	ldr	r0, [r7, #12]
20001b22:	f000 fef9 	bl	20002918 <HAL_restore_interrupts>

    /* Run the loop until state returns I2C_FAILED  or I2C_SUCESS*/
    do {
        i2c_status = this_i2c->master_status;
20001b26:	687b      	ldr	r3, [r7, #4]
20001b28:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
20001b2c:	72fb      	strb	r3, [r7, #11]
    } while(I2C_IN_PROGRESS == i2c_status);
20001b2e:	7afb      	ldrb	r3, [r7, #11]
20001b30:	2b01      	cmp	r3, #1
20001b32:	d0f8      	beq.n	20001b26 <I2C_wait_complete+0x1e>
    return i2c_status;
20001b34:	7afb      	ldrb	r3, [r7, #11]
}
20001b36:	4618      	mov	r0, r3
20001b38:	f107 0710 	add.w	r7, r7, #16
20001b3c:	46bd      	mov	sp, r7
20001b3e:	bd80      	pop	{r7, pc}

20001b40 <enable_slave_if_required>:
 */
static void enable_slave_if_required
(
    i2c_instance_t * this_i2c
)
{
20001b40:	b580      	push	{r7, lr}
20001b42:	b082      	sub	sp, #8
20001b44:	af00      	add	r7, sp, #0
20001b46:	6078      	str	r0, [r7, #4]
    /*
     * This function is only called from within the ISR and so does not need
     * guarding on the register access.
     */
    if( 0 != this_i2c->is_slave_enabled )
20001b48:	687b      	ldr	r3, [r7, #4]
20001b4a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
20001b4e:	2b00      	cmp	r3, #0
20001b50:	d00a      	beq.n	20001b68 <enable_slave_if_required+0x28>
    {
        HAL_set_8bit_reg_field( this_i2c->base_address, AA, 0x01u );
20001b52:	687b      	ldr	r3, [r7, #4]
20001b54:	681b      	ldr	r3, [r3, #0]
20001b56:	4618      	mov	r0, r3
20001b58:	f04f 0102 	mov.w	r1, #2
20001b5c:	f04f 0204 	mov.w	r2, #4
20001b60:	f04f 0301 	mov.w	r3, #1
20001b64:	f000 ff0f 	bl	20002986 <HW_set_8bit_reg_field>
    }
}
20001b68:	f107 0708 	add.w	r7, r7, #8
20001b6c:	46bd      	mov	sp, r7
20001b6e:	bd80      	pop	{r7, pc}

20001b70 <I2C_isr>:
 */
void I2C_isr
(
    i2c_instance_t * this_i2c
)
{
20001b70:	b5b0      	push	{r4, r5, r7, lr}
20001b72:	b084      	sub	sp, #16
20001b74:	af00      	add	r7, sp, #0
20001b76:	6078      	str	r0, [r7, #4]
    volatile uint8_t status;
    uint8_t data;
    uint8_t hold_bus;
    uint8_t clear_irq = 1u;
20001b78:	f04f 0301 	mov.w	r3, #1
20001b7c:	73bb      	strb	r3, [r7, #14]

    status = HAL_get_8bit_reg( this_i2c->base_address, STATUS);
20001b7e:	687b      	ldr	r3, [r7, #4]
20001b80:	681b      	ldr	r3, [r3, #0]
20001b82:	f103 0304 	add.w	r3, r3, #4
20001b86:	4618      	mov	r0, r3
20001b88:	f000 fefb 	bl	20002982 <HW_get_8bit_reg>
20001b8c:	4603      	mov	r3, r0
20001b8e:	72fb      	strb	r3, [r7, #11]
    
    switch( status )
20001b90:	7afb      	ldrb	r3, [r7, #11]
20001b92:	b2db      	uxtb	r3, r3
20001b94:	f1a3 0308 	sub.w	r3, r3, #8
20001b98:	2bd8      	cmp	r3, #216	; 0xd8
20001b9a:	f200 84e3 	bhi.w	20002564 <I2C_isr+0x9f4>
20001b9e:	a201      	add	r2, pc, #4	; (adr r2, 20001ba4 <I2C_isr+0x34>)
20001ba0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20001ba4:	20001f09 	.word	0x20001f09
20001ba8:	20002565 	.word	0x20002565
20001bac:	20002565 	.word	0x20002565
20001bb0:	20002565 	.word	0x20002565
20001bb4:	20002565 	.word	0x20002565
20001bb8:	20002565 	.word	0x20002565
20001bbc:	20002565 	.word	0x20002565
20001bc0:	20002565 	.word	0x20002565
20001bc4:	20001f09 	.word	0x20001f09
20001bc8:	20002565 	.word	0x20002565
20001bcc:	20002565 	.word	0x20002565
20001bd0:	20002565 	.word	0x20002565
20001bd4:	20002565 	.word	0x20002565
20001bd8:	20002565 	.word	0x20002565
20001bdc:	20002565 	.word	0x20002565
20001be0:	20002565 	.word	0x20002565
20001be4:	20001fdf 	.word	0x20001fdf
20001be8:	20002565 	.word	0x20002565
20001bec:	20002565 	.word	0x20002565
20001bf0:	20002565 	.word	0x20002565
20001bf4:	20002565 	.word	0x20002565
20001bf8:	20002565 	.word	0x20002565
20001bfc:	20002565 	.word	0x20002565
20001c00:	20002565 	.word	0x20002565
20001c04:	20001faf 	.word	0x20001faf
20001c08:	20002565 	.word	0x20002565
20001c0c:	20002565 	.word	0x20002565
20001c10:	20002565 	.word	0x20002565
20001c14:	20002565 	.word	0x20002565
20001c18:	20002565 	.word	0x20002565
20001c1c:	20002565 	.word	0x20002565
20001c20:	20002565 	.word	0x20002565
20001c24:	20001fdf 	.word	0x20001fdf
20001c28:	20002565 	.word	0x20002565
20001c2c:	20002565 	.word	0x20002565
20001c30:	20002565 	.word	0x20002565
20001c34:	20002565 	.word	0x20002565
20001c38:	20002565 	.word	0x20002565
20001c3c:	20002565 	.word	0x20002565
20001c40:	20002565 	.word	0x20002565
20001c44:	2000208f 	.word	0x2000208f
20001c48:	20002565 	.word	0x20002565
20001c4c:	20002565 	.word	0x20002565
20001c50:	20002565 	.word	0x20002565
20001c54:	20002565 	.word	0x20002565
20001c58:	20002565 	.word	0x20002565
20001c5c:	20002565 	.word	0x20002565
20001c60:	20002565 	.word	0x20002565
20001c64:	20001f97 	.word	0x20001f97
20001c68:	20002565 	.word	0x20002565
20001c6c:	20002565 	.word	0x20002565
20001c70:	20002565 	.word	0x20002565
20001c74:	20002565 	.word	0x20002565
20001c78:	20002565 	.word	0x20002565
20001c7c:	20002565 	.word	0x20002565
20001c80:	20002565 	.word	0x20002565
20001c84:	200020bf 	.word	0x200020bf
20001c88:	20002565 	.word	0x20002565
20001c8c:	20002565 	.word	0x20002565
20001c90:	20002565 	.word	0x20002565
20001c94:	20002565 	.word	0x20002565
20001c98:	20002565 	.word	0x20002565
20001c9c:	20002565 	.word	0x20002565
20001ca0:	20002565 	.word	0x20002565
20001ca4:	2000213f 	.word	0x2000213f
20001ca8:	20002565 	.word	0x20002565
20001cac:	20002565 	.word	0x20002565
20001cb0:	20002565 	.word	0x20002565
20001cb4:	20002565 	.word	0x20002565
20001cb8:	20002565 	.word	0x20002565
20001cbc:	20002565 	.word	0x20002565
20001cc0:	20002565 	.word	0x20002565
20001cc4:	2000216f 	.word	0x2000216f
20001cc8:	20002565 	.word	0x20002565
20001ccc:	20002565 	.word	0x20002565
20001cd0:	20002565 	.word	0x20002565
20001cd4:	20002565 	.word	0x20002565
20001cd8:	20002565 	.word	0x20002565
20001cdc:	20002565 	.word	0x20002565
20001ce0:	20002565 	.word	0x20002565
20001ce4:	200021bf 	.word	0x200021bf
20001ce8:	20002565 	.word	0x20002565
20001cec:	20002565 	.word	0x20002565
20001cf0:	20002565 	.word	0x20002565
20001cf4:	20002565 	.word	0x20002565
20001cf8:	20002565 	.word	0x20002565
20001cfc:	20002565 	.word	0x20002565
20001d00:	20002565 	.word	0x20002565
20001d04:	20002289 	.word	0x20002289
20001d08:	20002565 	.word	0x20002565
20001d0c:	20002565 	.word	0x20002565
20001d10:	20002565 	.word	0x20002565
20001d14:	20002565 	.word	0x20002565
20001d18:	20002565 	.word	0x20002565
20001d1c:	20002565 	.word	0x20002565
20001d20:	20002565 	.word	0x20002565
20001d24:	2000227f 	.word	0x2000227f
20001d28:	20002565 	.word	0x20002565
20001d2c:	20002565 	.word	0x20002565
20001d30:	20002565 	.word	0x20002565
20001d34:	20002565 	.word	0x20002565
20001d38:	20002565 	.word	0x20002565
20001d3c:	20002565 	.word	0x20002565
20001d40:	20002565 	.word	0x20002565
20001d44:	20002289 	.word	0x20002289
20001d48:	20002565 	.word	0x20002565
20001d4c:	20002565 	.word	0x20002565
20001d50:	20002565 	.word	0x20002565
20001d54:	20002565 	.word	0x20002565
20001d58:	20002565 	.word	0x20002565
20001d5c:	20002565 	.word	0x20002565
20001d60:	20002565 	.word	0x20002565
20001d64:	2000227f 	.word	0x2000227f
20001d68:	20002565 	.word	0x20002565
20001d6c:	20002565 	.word	0x20002565
20001d70:	20002565 	.word	0x20002565
20001d74:	20002565 	.word	0x20002565
20001d78:	20002565 	.word	0x20002565
20001d7c:	20002565 	.word	0x20002565
20001d80:	20002565 	.word	0x20002565
20001d84:	200022e5 	.word	0x200022e5
20001d88:	20002565 	.word	0x20002565
20001d8c:	20002565 	.word	0x20002565
20001d90:	20002565 	.word	0x20002565
20001d94:	20002565 	.word	0x20002565
20001d98:	20002565 	.word	0x20002565
20001d9c:	20002565 	.word	0x20002565
20001da0:	20002565 	.word	0x20002565
20001da4:	20002233 	.word	0x20002233
20001da8:	20002565 	.word	0x20002565
20001dac:	20002565 	.word	0x20002565
20001db0:	20002565 	.word	0x20002565
20001db4:	20002565 	.word	0x20002565
20001db8:	20002565 	.word	0x20002565
20001dbc:	20002565 	.word	0x20002565
20001dc0:	20002565 	.word	0x20002565
20001dc4:	200022e5 	.word	0x200022e5
20001dc8:	20002565 	.word	0x20002565
20001dcc:	20002565 	.word	0x20002565
20001dd0:	20002565 	.word	0x20002565
20001dd4:	20002565 	.word	0x20002565
20001dd8:	20002565 	.word	0x20002565
20001ddc:	20002565 	.word	0x20002565
20001de0:	20002565 	.word	0x20002565
20001de4:	20002233 	.word	0x20002233
20001de8:	20002565 	.word	0x20002565
20001dec:	20002565 	.word	0x20002565
20001df0:	20002565 	.word	0x20002565
20001df4:	20002565 	.word	0x20002565
20001df8:	20002565 	.word	0x20002565
20001dfc:	20002565 	.word	0x20002565
20001e00:	20002565 	.word	0x20002565
20001e04:	20002357 	.word	0x20002357
20001e08:	20002565 	.word	0x20002565
20001e0c:	20002565 	.word	0x20002565
20001e10:	20002565 	.word	0x20002565
20001e14:	20002565 	.word	0x20002565
20001e18:	20002565 	.word	0x20002565
20001e1c:	20002565 	.word	0x20002565
20001e20:	20002565 	.word	0x20002565
20001e24:	20002449 	.word	0x20002449
20001e28:	20002565 	.word	0x20002565
20001e2c:	20002565 	.word	0x20002565
20001e30:	20002565 	.word	0x20002565
20001e34:	20002565 	.word	0x20002565
20001e38:	20002565 	.word	0x20002565
20001e3c:	20002565 	.word	0x20002565
20001e40:	20002565 	.word	0x20002565
20001e44:	20002449 	.word	0x20002449
20001e48:	20002565 	.word	0x20002565
20001e4c:	20002565 	.word	0x20002565
20001e50:	20002565 	.word	0x20002565
20001e54:	20002565 	.word	0x20002565
20001e58:	20002565 	.word	0x20002565
20001e5c:	20002565 	.word	0x20002565
20001e60:	20002565 	.word	0x20002565
20001e64:	20002449 	.word	0x20002449
20001e68:	20002565 	.word	0x20002565
20001e6c:	20002565 	.word	0x20002565
20001e70:	20002565 	.word	0x20002565
20001e74:	20002565 	.word	0x20002565
20001e78:	20002565 	.word	0x20002565
20001e7c:	20002565 	.word	0x20002565
20001e80:	20002565 	.word	0x20002565
20001e84:	20002513 	.word	0x20002513
20001e88:	20002565 	.word	0x20002565
20001e8c:	20002565 	.word	0x20002565
20001e90:	20002565 	.word	0x20002565
20001e94:	20002565 	.word	0x20002565
20001e98:	20002565 	.word	0x20002565
20001e9c:	20002565 	.word	0x20002565
20001ea0:	20002565 	.word	0x20002565
20001ea4:	20002513 	.word	0x20002513
20001ea8:	20002565 	.word	0x20002565
20001eac:	20002565 	.word	0x20002565
20001eb0:	20002565 	.word	0x20002565
20001eb4:	20002565 	.word	0x20002565
20001eb8:	20002565 	.word	0x20002565
20001ebc:	20002565 	.word	0x20002565
20001ec0:	20002565 	.word	0x20002565
20001ec4:	20002565 	.word	0x20002565
20001ec8:	20002565 	.word	0x20002565
20001ecc:	20002565 	.word	0x20002565
20001ed0:	20002565 	.word	0x20002565
20001ed4:	20002565 	.word	0x20002565
20001ed8:	20002565 	.word	0x20002565
20001edc:	20002565 	.word	0x20002565
20001ee0:	20002565 	.word	0x20002565
20001ee4:	2000241b 	.word	0x2000241b
20001ee8:	20002565 	.word	0x20002565
20001eec:	20002565 	.word	0x20002565
20001ef0:	20002565 	.word	0x20002565
20001ef4:	20002565 	.word	0x20002565
20001ef8:	20002565 	.word	0x20002565
20001efc:	20002565 	.word	0x20002565
20001f00:	20002565 	.word	0x20002565
20001f04:	200025b9 	.word	0x200025b9
    {
        /************** MASTER TRANSMITTER / RECEIVER *******************/
      
        case ST_START: /* start has been xmt'd */
        case ST_RESTART: /* repeated start has been xmt'd */
            HAL_set_8bit_reg_field( this_i2c->base_address, STA, 0x00u);
20001f08:	687b      	ldr	r3, [r7, #4]
20001f0a:	681b      	ldr	r3, [r3, #0]
20001f0c:	4618      	mov	r0, r3
20001f0e:	f04f 0105 	mov.w	r1, #5
20001f12:	f04f 0220 	mov.w	r2, #32
20001f16:	f04f 0300 	mov.w	r3, #0
20001f1a:	f000 fd34 	bl	20002986 <HW_set_8bit_reg_field>
            HAL_set_8bit_reg( this_i2c->base_address, DATA, this_i2c->target_addr); /* write call address */
20001f1e:	687b      	ldr	r3, [r7, #4]
20001f20:	681b      	ldr	r3, [r3, #0]
20001f22:	f103 0208 	add.w	r2, r3, #8
20001f26:	687b      	ldr	r3, [r7, #4]
20001f28:	689b      	ldr	r3, [r3, #8]
20001f2a:	4610      	mov	r0, r2
20001f2c:	4619      	mov	r1, r3
20001f2e:	f000 fd26 	bl	2000297e <HW_set_8bit_reg>
            HAL_set_8bit_reg_field( this_i2c->base_address, DIR, this_i2c->dir); /* set direction bit */
20001f32:	687b      	ldr	r3, [r7, #4]
20001f34:	681b      	ldr	r3, [r3, #0]
20001f36:	f103 0208 	add.w	r2, r3, #8
20001f3a:	687b      	ldr	r3, [r7, #4]
20001f3c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20001f3e:	4610      	mov	r0, r2
20001f40:	f04f 0100 	mov.w	r1, #0
20001f44:	f04f 0201 	mov.w	r2, #1
20001f48:	f000 fd1d 	bl	20002986 <HW_set_8bit_reg_field>
            if(this_i2c->dir == WRITE_DIR)
20001f4c:	687b      	ldr	r3, [r7, #4]
20001f4e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20001f50:	2b00      	cmp	r3, #0
20001f52:	d104      	bne.n	20001f5e <I2C_isr+0x3ee>
            {
                 this_i2c->master_tx_idx = 0u;
20001f54:	687b      	ldr	r3, [r7, #4]
20001f56:	f04f 0200 	mov.w	r2, #0
20001f5a:	621a      	str	r2, [r3, #32]
20001f5c:	e003      	b.n	20001f66 <I2C_isr+0x3f6>
            }
            else
            {
                 this_i2c->master_rx_idx = 0u;
20001f5e:	687b      	ldr	r3, [r7, #4]
20001f60:	f04f 0200 	mov.w	r2, #0
20001f64:	631a      	str	r2, [r3, #48]	; 0x30
            /*
             * Clear the pending transaction. This condition will be true if the slave 
             * has acquired the bus to carry out pending master transaction which 
             * it had received during its slave transmission or reception mode. 
             */
            if(this_i2c->is_transaction_pending)
20001f66:	687b      	ldr	r3, [r7, #4]
20001f68:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
20001f6c:	2b00      	cmp	r3, #0
20001f6e:	d004      	beq.n	20001f7a <I2C_isr+0x40a>
            {
                this_i2c->is_transaction_pending = 0u;
20001f70:	687b      	ldr	r3, [r7, #4]
20001f72:	f04f 0200 	mov.w	r2, #0
20001f76:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69

            /*
             * Make sure to update proper transaction after master START
             * or RESTART
             */
            if(this_i2c->transaction != this_i2c->pending_transaction)
20001f7a:	687b      	ldr	r3, [r7, #4]
20001f7c:	7b1a      	ldrb	r2, [r3, #12]
20001f7e:	687b      	ldr	r3, [r7, #4]
20001f80:	f893 306a 	ldrb.w	r3, [r3, #106]	; 0x6a
20001f84:	429a      	cmp	r2, r3
20001f86:	f000 8319 	beq.w	200025bc <I2C_isr+0xa4c>
            {
                this_i2c->transaction = this_i2c->pending_transaction;
20001f8a:	687b      	ldr	r3, [r7, #4]
20001f8c:	f893 206a 	ldrb.w	r2, [r3, #106]	; 0x6a
20001f90:	687b      	ldr	r3, [r7, #4]
20001f92:	731a      	strb	r2, [r3, #12]
            }
            break;
20001f94:	e31b      	b.n	200025ce <I2C_isr+0xa5e>
            
        case ST_LOST_ARB:
              /* Set start bit.  Let's keep trying!  Don't give up! */
              HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
20001f96:	687b      	ldr	r3, [r7, #4]
20001f98:	681b      	ldr	r3, [r3, #0]
20001f9a:	4618      	mov	r0, r3
20001f9c:	f04f 0105 	mov.w	r1, #5
20001fa0:	f04f 0220 	mov.w	r2, #32
20001fa4:	f04f 0301 	mov.w	r3, #1
20001fa8:	f000 fced 	bl	20002986 <HW_set_8bit_reg_field>
              break;
20001fac:	e30f      	b.n	200025ce <I2C_isr+0xa5e>
              break;

        /******************* MASTER TRANSMITTER *************************/
        case ST_SLAW_NACK:
            /* SLA+W has been transmitted; not ACK has been received - let's stop. */
            HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
20001fae:	687b      	ldr	r3, [r7, #4]
20001fb0:	681b      	ldr	r3, [r3, #0]
20001fb2:	4618      	mov	r0, r3
20001fb4:	f04f 0104 	mov.w	r1, #4
20001fb8:	f04f 0210 	mov.w	r2, #16
20001fbc:	f04f 0301 	mov.w	r3, #1
20001fc0:	f000 fce1 	bl	20002986 <HW_set_8bit_reg_field>
            this_i2c->master_status = I2C_FAILED;
20001fc4:	687b      	ldr	r3, [r7, #4]
20001fc6:	f04f 0202 	mov.w	r2, #2
20001fca:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            this_i2c->transaction = NO_TRANSACTION;
20001fce:	687b      	ldr	r3, [r7, #4]
20001fd0:	f04f 0200 	mov.w	r2, #0
20001fd4:	731a      	strb	r2, [r3, #12]
            enable_slave_if_required(this_i2c);
20001fd6:	6878      	ldr	r0, [r7, #4]
20001fd8:	f7ff fdb2 	bl	20001b40 <enable_slave_if_required>
            break;
20001fdc:	e2f7      	b.n	200025ce <I2C_isr+0xa5e>
            
        case ST_SLAW_ACK:
        case ST_TX_DATA_ACK:
            /* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
            if (this_i2c->master_tx_idx < this_i2c->master_tx_size)
20001fde:	687b      	ldr	r3, [r7, #4]
20001fe0:	6a1a      	ldr	r2, [r3, #32]
20001fe2:	687b      	ldr	r3, [r7, #4]
20001fe4:	69db      	ldr	r3, [r3, #28]
20001fe6:	429a      	cmp	r2, r3
20001fe8:	d212      	bcs.n	20002010 <I2C_isr+0x4a0>
            {    
                HAL_set_8bit_reg(this_i2c->base_address, DATA, (uint_fast8_t)this_i2c->master_tx_buffer[this_i2c->master_tx_idx++]);
20001fea:	687b      	ldr	r3, [r7, #4]
20001fec:	681b      	ldr	r3, [r3, #0]
20001fee:	f103 0108 	add.w	r1, r3, #8
20001ff2:	687b      	ldr	r3, [r7, #4]
20001ff4:	699a      	ldr	r2, [r3, #24]
20001ff6:	687b      	ldr	r3, [r7, #4]
20001ff8:	6a1b      	ldr	r3, [r3, #32]
20001ffa:	441a      	add	r2, r3
20001ffc:	7812      	ldrb	r2, [r2, #0]
20001ffe:	f103 0001 	add.w	r0, r3, #1
20002002:	687b      	ldr	r3, [r7, #4]
20002004:	6218      	str	r0, [r3, #32]
20002006:	4608      	mov	r0, r1
20002008:	4611      	mov	r1, r2
2000200a:	f000 fcb8 	bl	2000297e <HW_set_8bit_reg>
                    I2C_disable_irq( this_i2c );
                    clear_irq = 0u;
                }
                this_i2c->master_status = I2C_SUCCESS;
            }
            break;
2000200e:	e2de      	b.n	200025ce <I2C_isr+0xa5e>
            /* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
            if (this_i2c->master_tx_idx < this_i2c->master_tx_size)
            {    
                HAL_set_8bit_reg(this_i2c->base_address, DATA, (uint_fast8_t)this_i2c->master_tx_buffer[this_i2c->master_tx_idx++]);
            }
            else if ( this_i2c->transaction == MASTER_RANDOM_READ_TRANSACTION )
20002010:	687b      	ldr	r3, [r7, #4]
20002012:	7b1b      	ldrb	r3, [r3, #12]
20002014:	2b03      	cmp	r3, #3
20002016:	d10f      	bne.n	20002038 <I2C_isr+0x4c8>
            {
                /* We are finished sending the address offset part of a random read transaction.
                 * It is is time to send a restart in order to change direction. */
                 this_i2c->dir = READ_DIR;
20002018:	687b      	ldr	r3, [r7, #4]
2000201a:	f04f 0201 	mov.w	r2, #1
2000201e:	625a      	str	r2, [r3, #36]	; 0x24
                 HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
20002020:	687b      	ldr	r3, [r7, #4]
20002022:	681b      	ldr	r3, [r3, #0]
20002024:	4618      	mov	r0, r3
20002026:	f04f 0105 	mov.w	r1, #5
2000202a:	f04f 0220 	mov.w	r2, #32
2000202e:	f04f 0301 	mov.w	r3, #1
20002032:	f000 fca8 	bl	20002986 <HW_set_8bit_reg_field>
                    I2C_disable_irq( this_i2c );
                    clear_irq = 0u;
                }
                this_i2c->master_status = I2C_SUCCESS;
            }
            break;
20002036:	e2ca      	b.n	200025ce <I2C_isr+0xa5e>
            {
                /*
                 * Set the transaction back to NO_TRANSACTION to allow user to do further
                 * transaction
                 */
                this_i2c->transaction = NO_TRANSACTION;
20002038:	687b      	ldr	r3, [r7, #4]
2000203a:	f04f 0200 	mov.w	r2, #0
2000203e:	731a      	strb	r2, [r3, #12]
                hold_bus = this_i2c->options & I2C_HOLD_BUS;
20002040:	687b      	ldr	r3, [r7, #4]
20002042:	7d1b      	ldrb	r3, [r3, #20]
20002044:	f003 0301 	and.w	r3, r3, #1
20002048:	737b      	strb	r3, [r7, #13]

                /* Store the information of current I2C bus status in the bus_status*/
                this_i2c->bus_status  = hold_bus;
2000204a:	687b      	ldr	r3, [r7, #4]
2000204c:	7b7a      	ldrb	r2, [r7, #13]
2000204e:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
                if ( hold_bus == 0u )
20002052:	7b7b      	ldrb	r3, [r7, #13]
20002054:	2b00      	cmp	r3, #0
20002056:	d10e      	bne.n	20002076 <I2C_isr+0x506>
                { 
                    HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);  /*xmt stop condition */
20002058:	687b      	ldr	r3, [r7, #4]
2000205a:	681b      	ldr	r3, [r3, #0]
2000205c:	4618      	mov	r0, r3
2000205e:	f04f 0104 	mov.w	r1, #4
20002062:	f04f 0210 	mov.w	r2, #16
20002066:	f04f 0301 	mov.w	r3, #1
2000206a:	f000 fc8c 	bl	20002986 <HW_set_8bit_reg_field>
                    enable_slave_if_required(this_i2c);
2000206e:	6878      	ldr	r0, [r7, #4]
20002070:	f7ff fd66 	bl	20001b40 <enable_slave_if_required>
20002074:	e005      	b.n	20002082 <I2C_isr+0x512>
                }
                else
                {
                    I2C_disable_irq( this_i2c );
20002076:	6878      	ldr	r0, [r7, #4]
20002078:	f000 fb48 	bl	2000270c <I2C_disable_irq>
                    clear_irq = 0u;
2000207c:	f04f 0300 	mov.w	r3, #0
20002080:	73bb      	strb	r3, [r7, #14]
                }
                this_i2c->master_status = I2C_SUCCESS;
20002082:	687b      	ldr	r3, [r7, #4]
20002084:	f04f 0200 	mov.w	r2, #0
20002088:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            }
            break;
2000208c:	e29f      	b.n	200025ce <I2C_isr+0xa5e>
            /* data byte SENT, ACK to be received
             * In fact, this means we've received a NACK (This may not be 
             * obvious, but if we've rec'd an ACK then we would be in state 
             * 0x28!) hence, let's send a stop bit
             */
            HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);/* xmt stop condition */
2000208e:	687b      	ldr	r3, [r7, #4]
20002090:	681b      	ldr	r3, [r3, #0]
20002092:	4618      	mov	r0, r3
20002094:	f04f 0104 	mov.w	r1, #4
20002098:	f04f 0210 	mov.w	r2, #16
2000209c:	f04f 0301 	mov.w	r3, #1
200020a0:	f000 fc71 	bl	20002986 <HW_set_8bit_reg_field>
            this_i2c->master_status = I2C_FAILED;
200020a4:	687b      	ldr	r3, [r7, #4]
200020a6:	f04f 0202 	mov.w	r2, #2
200020aa:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
200020ae:	687b      	ldr	r3, [r7, #4]
200020b0:	f04f 0200 	mov.w	r2, #0
200020b4:	731a      	strb	r2, [r3, #12]
            enable_slave_if_required(this_i2c);
200020b6:	6878      	ldr	r0, [r7, #4]
200020b8:	f7ff fd42 	bl	20001b40 <enable_slave_if_required>
            break;
200020bc:	e287      	b.n	200025ce <I2C_isr+0xa5e>
      /* STATUS codes 08H, 10H, 38H are all covered in MTX mode */
        case ST_SLAR_ACK: /* SLA+R tx'ed. */
            /* Let's make sure we ACK the first data byte received (set AA bit in CTRL) unless
             * the next byte is the last byte of the read transaction.
             */
            if(this_i2c->master_rx_size > 1u)
200020be:	687b      	ldr	r3, [r7, #4]
200020c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200020c2:	2b01      	cmp	r3, #1
200020c4:	d90b      	bls.n	200020de <I2C_isr+0x56e>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
200020c6:	687b      	ldr	r3, [r7, #4]
200020c8:	681b      	ldr	r3, [r3, #0]
200020ca:	4618      	mov	r0, r3
200020cc:	f04f 0102 	mov.w	r1, #2
200020d0:	f04f 0204 	mov.w	r2, #4
200020d4:	f04f 0301 	mov.w	r3, #1
200020d8:	f000 fc55 	bl	20002986 <HW_set_8bit_reg_field>
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
                HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
                this_i2c->master_status = I2C_SUCCESS;
                this_i2c->transaction = NO_TRANSACTION;
            }
            break;
200020dc:	e277      	b.n	200025ce <I2C_isr+0xa5e>
             */
            if(this_i2c->master_rx_size > 1u)
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
            }
            else if(1u == this_i2c->master_rx_size)
200020de:	687b      	ldr	r3, [r7, #4]
200020e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200020e2:	2b01      	cmp	r3, #1
200020e4:	d10b      	bne.n	200020fe <I2C_isr+0x58e>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u);
200020e6:	687b      	ldr	r3, [r7, #4]
200020e8:	681b      	ldr	r3, [r3, #0]
200020ea:	4618      	mov	r0, r3
200020ec:	f04f 0102 	mov.w	r1, #2
200020f0:	f04f 0204 	mov.w	r2, #4
200020f4:	f04f 0300 	mov.w	r3, #0
200020f8:	f000 fc45 	bl	20002986 <HW_set_8bit_reg_field>
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
                HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
                this_i2c->master_status = I2C_SUCCESS;
                this_i2c->transaction = NO_TRANSACTION;
            }
            break;
200020fc:	e267      	b.n	200025ce <I2C_isr+0xa5e>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u);
            }
            else /* this_i2c->master_rx_size == 0u */
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
200020fe:	687b      	ldr	r3, [r7, #4]
20002100:	681b      	ldr	r3, [r3, #0]
20002102:	4618      	mov	r0, r3
20002104:	f04f 0102 	mov.w	r1, #2
20002108:	f04f 0204 	mov.w	r2, #4
2000210c:	f04f 0301 	mov.w	r3, #1
20002110:	f000 fc39 	bl	20002986 <HW_set_8bit_reg_field>
                HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
20002114:	687b      	ldr	r3, [r7, #4]
20002116:	681b      	ldr	r3, [r3, #0]
20002118:	4618      	mov	r0, r3
2000211a:	f04f 0104 	mov.w	r1, #4
2000211e:	f04f 0210 	mov.w	r2, #16
20002122:	f04f 0301 	mov.w	r3, #1
20002126:	f000 fc2e 	bl	20002986 <HW_set_8bit_reg_field>
                this_i2c->master_status = I2C_SUCCESS;
2000212a:	687b      	ldr	r3, [r7, #4]
2000212c:	f04f 0200 	mov.w	r2, #0
20002130:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
                this_i2c->transaction = NO_TRANSACTION;
20002134:	687b      	ldr	r3, [r7, #4]
20002136:	f04f 0200 	mov.w	r2, #0
2000213a:	731a      	strb	r2, [r3, #12]
            }
            break;
2000213c:	e247      	b.n	200025ce <I2C_isr+0xa5e>
            
        case ST_SLAR_NACK: /* SLA+R tx'ed; let's release the bus (send a stop condition) */
            HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);
2000213e:	687b      	ldr	r3, [r7, #4]
20002140:	681b      	ldr	r3, [r3, #0]
20002142:	4618      	mov	r0, r3
20002144:	f04f 0104 	mov.w	r1, #4
20002148:	f04f 0210 	mov.w	r2, #16
2000214c:	f04f 0301 	mov.w	r3, #1
20002150:	f000 fc19 	bl	20002986 <HW_set_8bit_reg_field>
            this_i2c->master_status = I2C_FAILED;
20002154:	687b      	ldr	r3, [r7, #4]
20002156:	f04f 0202 	mov.w	r2, #2
2000215a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
2000215e:	687b      	ldr	r3, [r7, #4]
20002160:	f04f 0200 	mov.w	r2, #0
20002164:	731a      	strb	r2, [r3, #12]
            enable_slave_if_required(this_i2c);
20002166:	6878      	ldr	r0, [r7, #4]
20002168:	f7ff fcea 	bl	20001b40 <enable_slave_if_required>
            break;
2000216c:	e22f      	b.n	200025ce <I2C_isr+0xa5e>
          
        case ST_RX_DATA_ACK: /* Data byte received, ACK returned */
            /* First, get the data */
            this_i2c->master_rx_buffer[this_i2c->master_rx_idx++] = HAL_get_8bit_reg(this_i2c->base_address, DATA);
2000216e:	687b      	ldr	r3, [r7, #4]
20002170:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20002172:	687a      	ldr	r2, [r7, #4]
20002174:	6b14      	ldr	r4, [r2, #48]	; 0x30
20002176:	eb03 0504 	add.w	r5, r3, r4
2000217a:	687b      	ldr	r3, [r7, #4]
2000217c:	681b      	ldr	r3, [r3, #0]
2000217e:	f103 0308 	add.w	r3, r3, #8
20002182:	4618      	mov	r0, r3
20002184:	f000 fbfd 	bl	20002982 <HW_get_8bit_reg>
20002188:	4603      	mov	r3, r0
2000218a:	702b      	strb	r3, [r5, #0]
2000218c:	f104 0201 	add.w	r2, r4, #1
20002190:	687b      	ldr	r3, [r7, #4]
20002192:	631a      	str	r2, [r3, #48]	; 0x30
            if( this_i2c->master_rx_idx >= (this_i2c->master_rx_size - 1u))
20002194:	687b      	ldr	r3, [r7, #4]
20002196:	6b1a      	ldr	r2, [r3, #48]	; 0x30
20002198:	687b      	ldr	r3, [r7, #4]
2000219a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000219c:	f103 33ff 	add.w	r3, r3, #4294967295
200021a0:	429a      	cmp	r2, r3
200021a2:	f0c0 820d 	bcc.w	200025c0 <I2C_isr+0xa50>
            {
                /* If we're at the second last byte, let's set AA to 0 so
                 * we return a NACK at the last byte. */
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u);
200021a6:	687b      	ldr	r3, [r7, #4]
200021a8:	681b      	ldr	r3, [r3, #0]
200021aa:	4618      	mov	r0, r3
200021ac:	f04f 0102 	mov.w	r1, #2
200021b0:	f04f 0204 	mov.w	r2, #4
200021b4:	f04f 0300 	mov.w	r3, #0
200021b8:	f000 fbe5 	bl	20002986 <HW_set_8bit_reg_field>
            }
            break;
200021bc:	e207      	b.n	200025ce <I2C_isr+0xa5e>
            
        case ST_RX_DATA_NACK: /* Data byte received, NACK returned */
            /* Get the data, then send a stop condition */
            this_i2c->master_rx_buffer[this_i2c->master_rx_idx] = HAL_get_8bit_reg(this_i2c->base_address, DATA);
200021be:	687b      	ldr	r3, [r7, #4]
200021c0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
200021c2:	687b      	ldr	r3, [r7, #4]
200021c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200021c6:	eb02 0403 	add.w	r4, r2, r3
200021ca:	687b      	ldr	r3, [r7, #4]
200021cc:	681b      	ldr	r3, [r3, #0]
200021ce:	f103 0308 	add.w	r3, r3, #8
200021d2:	4618      	mov	r0, r3
200021d4:	f000 fbd5 	bl	20002982 <HW_get_8bit_reg>
200021d8:	4603      	mov	r3, r0
200021da:	7023      	strb	r3, [r4, #0]
          
            hold_bus = this_i2c->options & I2C_HOLD_BUS; 
200021dc:	687b      	ldr	r3, [r7, #4]
200021de:	7d1b      	ldrb	r3, [r3, #20]
200021e0:	f003 0301 	and.w	r3, r3, #1
200021e4:	737b      	strb	r3, [r7, #13]

            /* Store the information of current I2C bus status in the bus_status*/
            this_i2c->bus_status  = hold_bus;
200021e6:	687b      	ldr	r3, [r7, #4]
200021e8:	7b7a      	ldrb	r2, [r7, #13]
200021ea:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
            if ( hold_bus == 0u )
200021ee:	7b7b      	ldrb	r3, [r7, #13]
200021f0:	2b00      	cmp	r3, #0
200021f2:	d10e      	bne.n	20002212 <I2C_isr+0x6a2>
            { 
                HAL_set_8bit_reg_field(this_i2c->base_address, STO, 0x01u);  /*xmt stop condition */
200021f4:	687b      	ldr	r3, [r7, #4]
200021f6:	681b      	ldr	r3, [r3, #0]
200021f8:	4618      	mov	r0, r3
200021fa:	f04f 0104 	mov.w	r1, #4
200021fe:	f04f 0210 	mov.w	r2, #16
20002202:	f04f 0301 	mov.w	r3, #1
20002206:	f000 fbbe 	bl	20002986 <HW_set_8bit_reg_field>

                /* Bus is released, now we can start listening to bus, if it is slave */
                   enable_slave_if_required(this_i2c);
2000220a:	6878      	ldr	r0, [r7, #4]
2000220c:	f7ff fc98 	bl	20001b40 <enable_slave_if_required>
20002210:	e005      	b.n	2000221e <I2C_isr+0x6ae>
            }
            else
            {
                I2C_disable_irq( this_i2c );
20002212:	6878      	ldr	r0, [r7, #4]
20002214:	f000 fa7a 	bl	2000270c <I2C_disable_irq>
                clear_irq = 0u;
20002218:	f04f 0300 	mov.w	r3, #0
2000221c:	73bb      	strb	r3, [r7, #14]
            }
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
2000221e:	687b      	ldr	r3, [r7, #4]
20002220:	f04f 0200 	mov.w	r2, #0
20002224:	731a      	strb	r2, [r3, #12]
            this_i2c->master_status = I2C_SUCCESS;
20002226:	687b      	ldr	r3, [r7, #4]
20002228:	f04f 0200 	mov.w	r2, #0
2000222c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            break;
20002230:	e1cd      	b.n	200025ce <I2C_isr+0xa5e>
        
        /******************** SLAVE RECEIVER **************************/
        case ST_GCA_NACK: /* NACK after, GCA addressing */
        case ST_SLA_NACK: /* Re-enable AA (assert ack) bit for future transmissions */
            HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u);
20002232:	687b      	ldr	r3, [r7, #4]
20002234:	681b      	ldr	r3, [r3, #0]
20002236:	4618      	mov	r0, r3
20002238:	f04f 0102 	mov.w	r1, #2
2000223c:	f04f 0204 	mov.w	r2, #4
20002240:	f04f 0301 	mov.w	r3, #1
20002244:	f000 fb9f 	bl	20002986 <HW_set_8bit_reg_field>

            this_i2c->transaction = NO_TRANSACTION;
20002248:	687b      	ldr	r3, [r7, #4]
2000224a:	f04f 0200 	mov.w	r2, #0
2000224e:	731a      	strb	r2, [r3, #12]
            this_i2c->slave_status = I2C_SUCCESS;
20002250:	687b      	ldr	r3, [r7, #4]
20002252:	f04f 0200 	mov.w	r2, #0
20002256:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
            
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
2000225a:	687b      	ldr	r3, [r7, #4]
2000225c:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
20002260:	2b00      	cmp	r3, #0
20002262:	f000 81af 	beq.w	200025c4 <I2C_isr+0xa54>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
20002266:	687b      	ldr	r3, [r7, #4]
20002268:	681b      	ldr	r3, [r3, #0]
2000226a:	4618      	mov	r0, r3
2000226c:	f04f 0105 	mov.w	r1, #5
20002270:	f04f 0220 	mov.w	r2, #32
20002274:	f04f 0301 	mov.w	r3, #1
20002278:	f000 fb85 	bl	20002986 <HW_set_8bit_reg_field>
            }
            break;
2000227c:	e1a7      	b.n	200025ce <I2C_isr+0xa5e>
        case ST_SLV_LA: /* Arbitr. lost (SLA rec'd) */
            /*
             *  We lost arbitration and either the GCE or our address was the
             *  one received so pend the master operation we were starting.
             */
            this_i2c->is_transaction_pending = 1u;
2000227e:	687b      	ldr	r3, [r7, #4]
20002280:	f04f 0201 	mov.w	r2, #1
20002284:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
            /* Fall through to normal ST processing as we are now in slave mode */

        case ST_GCA: /* General call address received, ACK returned */
        case ST_SLAVE_SLAW: /* SLA+W received, ACK returned */
            this_i2c->transaction = WRITE_SLAVE_TRANSACTION;
20002288:	687b      	ldr	r3, [r7, #4]
2000228a:	f04f 0204 	mov.w	r2, #4
2000228e:	731a      	strb	r2, [r3, #12]
            this_i2c->slave_rx_idx = 0u;
20002290:	687b      	ldr	r3, [r7, #4]
20002292:	f04f 0200 	mov.w	r2, #0
20002296:	651a      	str	r2, [r3, #80]	; 0x50
            this_i2c->random_read_addr = 0u;
20002298:	687b      	ldr	r3, [r7, #4]
2000229a:	f04f 0200 	mov.w	r2, #0
2000229e:	611a      	str	r2, [r3, #16]
            /*
             * If Start Bit is set clear it, but store that information since it is because of
             * pending transaction
             */
            if(HAL_get_8bit_reg_field(this_i2c->base_address, STA))
200022a0:	687b      	ldr	r3, [r7, #4]
200022a2:	681b      	ldr	r3, [r3, #0]
200022a4:	4618      	mov	r0, r3
200022a6:	f04f 0105 	mov.w	r1, #5
200022aa:	f04f 0220 	mov.w	r2, #32
200022ae:	f000 fb78 	bl	200029a2 <HW_get_8bit_reg_field>
200022b2:	4603      	mov	r3, r0
200022b4:	2b00      	cmp	r3, #0
200022b6:	d00f      	beq.n	200022d8 <I2C_isr+0x768>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x00u);
200022b8:	687b      	ldr	r3, [r7, #4]
200022ba:	681b      	ldr	r3, [r3, #0]
200022bc:	4618      	mov	r0, r3
200022be:	f04f 0105 	mov.w	r1, #5
200022c2:	f04f 0220 	mov.w	r2, #32
200022c6:	f04f 0300 	mov.w	r3, #0
200022ca:	f000 fb5c 	bl	20002986 <HW_set_8bit_reg_field>
                this_i2c->is_transaction_pending = 1u;
200022ce:	687b      	ldr	r3, [r7, #4]
200022d0:	f04f 0201 	mov.w	r2, #1
200022d4:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
            }
            this_i2c->slave_status = I2C_IN_PROGRESS;
200022d8:	687b      	ldr	r3, [r7, #4]
200022da:	f04f 0201 	mov.w	r2, #1
200022de:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
#ifdef INCLUDE_SLA_IN_RX_PAYLOAD
            /* Fall through to put address as first byte in payload buffer */
#else
            /* Only break from this case if the slave address must NOT be included at the
             * beginning of the received write data. */
            break;
200022e2:	e174      	b.n	200025ce <I2C_isr+0xa5e>
#endif            
        case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
        case ST_RDATA: /* DATA received; must clear DATA register */
            if((this_i2c->slave_rx_buffer != (uint8_t *)0)
200022e4:	687b      	ldr	r3, [r7, #4]
200022e6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200022e8:	2b00      	cmp	r3, #0
200022ea:	d021      	beq.n	20002330 <I2C_isr+0x7c0>
               && (this_i2c->slave_rx_idx < this_i2c->slave_rx_size))
200022ec:	687b      	ldr	r3, [r7, #4]
200022ee:	6d1a      	ldr	r2, [r3, #80]	; 0x50
200022f0:	687b      	ldr	r3, [r7, #4]
200022f2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
             * beginning of the received write data. */
            break;
#endif            
        case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
        case ST_RDATA: /* DATA received; must clear DATA register */
            if((this_i2c->slave_rx_buffer != (uint8_t *)0)
200022f4:	429a      	cmp	r2, r3
200022f6:	d21b      	bcs.n	20002330 <I2C_isr+0x7c0>
               && (this_i2c->slave_rx_idx < this_i2c->slave_rx_size))
            {
                data = HAL_get_8bit_reg(this_i2c->base_address, DATA);
200022f8:	687b      	ldr	r3, [r7, #4]
200022fa:	681b      	ldr	r3, [r3, #0]
200022fc:	f103 0308 	add.w	r3, r3, #8
20002300:	4618      	mov	r0, r3
20002302:	f000 fb3e 	bl	20002982 <HW_get_8bit_reg>
20002306:	4603      	mov	r3, r0
20002308:	733b      	strb	r3, [r7, #12]
                this_i2c->slave_rx_buffer[this_i2c->slave_rx_idx++] = data;
2000230a:	687b      	ldr	r3, [r7, #4]
2000230c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
2000230e:	687b      	ldr	r3, [r7, #4]
20002310:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20002312:	441a      	add	r2, r3
20002314:	7b39      	ldrb	r1, [r7, #12]
20002316:	7011      	strb	r1, [r2, #0]
20002318:	f103 0201 	add.w	r2, r3, #1
2000231c:	687b      	ldr	r3, [r7, #4]
2000231e:	651a      	str	r2, [r3, #80]	; 0x50
                {
                    /* Ignore the slave address byte in the random read address
                       computation in the case where INCLUDE_SLA_IN_RX_PAYLOAD
                       is defined. */
#endif
                    this_i2c->random_read_addr = (this_i2c->random_read_addr << 8) + data;
20002320:	687b      	ldr	r3, [r7, #4]
20002322:	691b      	ldr	r3, [r3, #16]
20002324:	ea4f 2203 	mov.w	r2, r3, lsl #8
20002328:	7b3b      	ldrb	r3, [r7, #12]
2000232a:	441a      	add	r2, r3
2000232c:	687b      	ldr	r3, [r7, #4]
2000232e:	611a      	str	r2, [r3, #16]
#ifdef INCLUDE_SLA_IN_RX_PAYLOAD
                }
#endif
            }
            
            if(this_i2c->slave_rx_idx >= this_i2c->slave_rx_size)
20002330:	687b      	ldr	r3, [r7, #4]
20002332:	6d1a      	ldr	r2, [r3, #80]	; 0x50
20002334:	687b      	ldr	r3, [r7, #4]
20002336:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20002338:	429a      	cmp	r2, r3
2000233a:	f0c0 8145 	bcc.w	200025c8 <I2C_isr+0xa58>
            {
                /* Rx buffer is full. NACK next received byte. */
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u); 
2000233e:	687b      	ldr	r3, [r7, #4]
20002340:	681b      	ldr	r3, [r3, #0]
20002342:	4618      	mov	r0, r3
20002344:	f04f 0102 	mov.w	r1, #2
20002348:	f04f 0204 	mov.w	r2, #4
2000234c:	f04f 0300 	mov.w	r3, #0
20002350:	f000 fb19 	bl	20002986 <HW_set_8bit_reg_field>
            }
            break;
20002354:	e13b      	b.n	200025ce <I2C_isr+0xa5e>
            /* STOP or repeated START occurred. */
            /* We cannot be sure if the transaction has actually completed as
             * this hardware state reports that either a STOP or repeated START
             * condition has occurred. We assume that this is a repeated START
             * if the transaction was a write from the master to this point.*/
            if ( this_i2c->transaction == WRITE_SLAVE_TRANSACTION )
20002356:	687b      	ldr	r3, [r7, #4]
20002358:	7b1b      	ldrb	r3, [r3, #12]
2000235a:	2b04      	cmp	r3, #4
2000235c:	d13c      	bne.n	200023d8 <I2C_isr+0x868>
            {
                if ( this_i2c->slave_rx_idx == this_i2c->slave_mem_offset_length )
2000235e:	687b      	ldr	r3, [r7, #4]
20002360:	6d1a      	ldr	r2, [r3, #80]	; 0x50
20002362:	687b      	ldr	r3, [r7, #4]
20002364:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20002366:	429a      	cmp	r2, r3
20002368:	d103      	bne.n	20002372 <I2C_isr+0x802>
                {
                    this_i2c->slave_tx_idx = this_i2c->random_read_addr;
2000236a:	687b      	ldr	r3, [r7, #4]
2000236c:	691a      	ldr	r2, [r3, #16]
2000236e:	687b      	ldr	r3, [r7, #4]
20002370:	645a      	str	r2, [r3, #68]	; 0x44
                }
                /* Call the slave's write transaction handler if it exists. */
                if ( this_i2c->slave_write_handler != 0u )
20002372:	687b      	ldr	r3, [r7, #4]
20002374:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20002376:	2b00      	cmp	r3, #0
20002378:	d022      	beq.n	200023c0 <I2C_isr+0x850>
                {
                    i2c_slave_handler_ret_t h_ret;
                    h_ret = this_i2c->slave_write_handler( this_i2c, this_i2c->slave_rx_buffer, (uint16_t)this_i2c->slave_rx_idx );
2000237a:	687b      	ldr	r3, [r7, #4]
2000237c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2000237e:	687a      	ldr	r2, [r7, #4]
20002380:	6c91      	ldr	r1, [r2, #72]	; 0x48
20002382:	687a      	ldr	r2, [r7, #4]
20002384:	6d12      	ldr	r2, [r2, #80]	; 0x50
20002386:	b292      	uxth	r2, r2
20002388:	6878      	ldr	r0, [r7, #4]
2000238a:	4798      	blx	r3
2000238c:	4603      	mov	r3, r0
2000238e:	73fb      	strb	r3, [r7, #15]
                    if ( I2C_REENABLE_SLAVE_RX == h_ret )
20002390:	7bfb      	ldrb	r3, [r7, #15]
20002392:	2b00      	cmp	r3, #0
20002394:	d103      	bne.n	2000239e <I2C_isr+0x82e>
                    {
                        /* There is a small risk that the write handler could
                         * call I2C_disable_slave() but return
                         * I2C_REENABLE_SLAVE_RX in error so we only enable
                         * ACKs if still in slave mode. */
                         enable_slave_if_required(this_i2c);
20002396:	6878      	ldr	r0, [r7, #4]
20002398:	f7ff fbd2 	bl	20001b40 <enable_slave_if_required>
                    }
                }
                else
                {
                    /* Re-enable address acknowledge in case we were ready to nack the next received byte. */
                    HAL_set_8bit_reg_field( this_i2c->base_address, AA, 0x01u );
2000239c:	e023      	b.n	200023e6 <I2C_isr+0x876>
                         * ACKs if still in slave mode. */
                         enable_slave_if_required(this_i2c);
                    }
                    else
                    {
                        HAL_set_8bit_reg_field( this_i2c->base_address, AA, 0x0u );
2000239e:	687b      	ldr	r3, [r7, #4]
200023a0:	681b      	ldr	r3, [r3, #0]
200023a2:	4618      	mov	r0, r3
200023a4:	f04f 0102 	mov.w	r1, #2
200023a8:	f04f 0204 	mov.w	r2, #4
200023ac:	f04f 0300 	mov.w	r3, #0
200023b0:	f000 fae9 	bl	20002986 <HW_set_8bit_reg_field>
                        /* Clear slave mode flag as well otherwise in mixed
                         * master/slave applications, the AA bit will get set by
                         * subsequent master operations. */
                        this_i2c->is_slave_enabled = 0u;
200023b4:	687b      	ldr	r3, [r7, #4]
200023b6:	f04f 0200 	mov.w	r2, #0
200023ba:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
                    }
                }
                else
                {
                    /* Re-enable address acknowledge in case we were ready to nack the next received byte. */
                    HAL_set_8bit_reg_field( this_i2c->base_address, AA, 0x01u );
200023be:	e012      	b.n	200023e6 <I2C_isr+0x876>
200023c0:	687b      	ldr	r3, [r7, #4]
200023c2:	681b      	ldr	r3, [r3, #0]
200023c4:	4618      	mov	r0, r3
200023c6:	f04f 0102 	mov.w	r1, #2
200023ca:	f04f 0204 	mov.w	r2, #4
200023ce:	f04f 0301 	mov.w	r3, #1
200023d2:	f000 fad8 	bl	20002986 <HW_set_8bit_reg_field>
200023d6:	e006      	b.n	200023e6 <I2C_isr+0x876>
            {
                /*
                 * Reset slave_tx_idx so that a subsequent read will result in the slave's
                 * transmit buffer being sent from the first byte.
                 */
                this_i2c->slave_tx_idx = 0u;
200023d8:	687b      	ldr	r3, [r7, #4]
200023da:	f04f 0200 	mov.w	r2, #0
200023de:	645a      	str	r2, [r3, #68]	; 0x44
                /*
                 * See if we need to re-enable acknowledgement as some error conditions, such
                 * as a master prematurely ending a transfer, can see us get here with AA set
                 * to 0 which will disable slave operation if we are not careful.
                 */
                enable_slave_if_required(this_i2c);
200023e0:	6878      	ldr	r0, [r7, #4]
200023e2:	f7ff fbad 	bl	20001b40 <enable_slave_if_required>
            }

            /* Mark any previous master write transaction as complete. */
            this_i2c->slave_status = I2C_SUCCESS;
200023e6:	687b      	ldr	r3, [r7, #4]
200023e8:	f04f 0200 	mov.w	r2, #0
200023ec:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
            
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
200023f0:	687b      	ldr	r3, [r7, #4]
200023f2:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
200023f6:	2b00      	cmp	r3, #0
200023f8:	d00a      	beq.n	20002410 <I2C_isr+0x8a0>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
200023fa:	687b      	ldr	r3, [r7, #4]
200023fc:	681b      	ldr	r3, [r3, #0]
200023fe:	4618      	mov	r0, r3
20002400:	f04f 0105 	mov.w	r1, #5
20002404:	f04f 0220 	mov.w	r2, #32
20002408:	f04f 0301 	mov.w	r3, #1
2000240c:	f000 fabb 	bl	20002986 <HW_set_8bit_reg_field>

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
20002410:	687b      	ldr	r3, [r7, #4]
20002412:	f04f 0200 	mov.w	r2, #0
20002416:	731a      	strb	r2, [r3, #12]

            break;
20002418:	e0d9      	b.n	200025ce <I2C_isr+0xa5e>
        case ST_SLV_RST: /* SMBUS ONLY: timeout state. must clear interrupt */
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction.
             */
            this_i2c->transaction = NO_TRANSACTION;
2000241a:	687b      	ldr	r3, [r7, #4]
2000241c:	f04f 0200 	mov.w	r2, #0
20002420:	731a      	strb	r2, [r3, #12]
            /*
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte.
             */
            this_i2c->slave_tx_idx = 0u;
20002422:	687b      	ldr	r3, [r7, #4]
20002424:	f04f 0200 	mov.w	r2, #0
20002428:	645a      	str	r2, [r3, #68]	; 0x44
            /*
             * Clear status to I2C_FAILED only if there was an operation in progress.
             */
            if(I2C_IN_PROGRESS == this_i2c->slave_status)
2000242a:	687b      	ldr	r3, [r7, #4]
2000242c:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
20002430:	b2db      	uxtb	r3, r3
20002432:	2b01      	cmp	r3, #1
20002434:	d104      	bne.n	20002440 <I2C_isr+0x8d0>
            {
                this_i2c->slave_status = I2C_FAILED;
20002436:	687b      	ldr	r3, [r7, #4]
20002438:	f04f 0202 	mov.w	r2, #2
2000243c:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
            }

            enable_slave_if_required(this_i2c); /* Make sure AA is set correctly */
20002440:	6878      	ldr	r0, [r7, #4]
20002442:	f7ff fb7d 	bl	20001b40 <enable_slave_if_required>

            break;
20002446:	e0c2      	b.n	200025ce <I2C_isr+0xa5e>
            
        /****************** SLAVE TRANSMITTER **************************/
        case ST_SLAVE_SLAR_ACK: /* SLA+R received, ACK returned */
        case ST_SLARW_LA:       /* Arbitration lost, and: */
        case ST_RACK:           /* Data tx'ed, ACK received */
            if ( status == ST_SLAVE_SLAR_ACK )
20002448:	7afb      	ldrb	r3, [r7, #11]
2000244a:	b2db      	uxtb	r3, r3
2000244c:	2ba8      	cmp	r3, #168	; 0xa8
2000244e:	d128      	bne.n	200024a2 <I2C_isr+0x932>
            {
                this_i2c->transaction = READ_SLAVE_TRANSACTION;
20002450:	687b      	ldr	r3, [r7, #4]
20002452:	f04f 0205 	mov.w	r2, #5
20002456:	731a      	strb	r2, [r3, #12]
                this_i2c->random_read_addr = 0u;
20002458:	687b      	ldr	r3, [r7, #4]
2000245a:	f04f 0200 	mov.w	r2, #0
2000245e:	611a      	str	r2, [r3, #16]
                this_i2c->slave_status = I2C_IN_PROGRESS;
20002460:	687b      	ldr	r3, [r7, #4]
20002462:	f04f 0201 	mov.w	r2, #1
20002466:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
                /* If Start Bit is set clear it, but store that information since it is because of
                 * pending transaction
                 */
                if(HAL_get_8bit_reg_field(this_i2c->base_address, STA))
2000246a:	687b      	ldr	r3, [r7, #4]
2000246c:	681b      	ldr	r3, [r3, #0]
2000246e:	4618      	mov	r0, r3
20002470:	f04f 0105 	mov.w	r1, #5
20002474:	f04f 0220 	mov.w	r2, #32
20002478:	f000 fa93 	bl	200029a2 <HW_get_8bit_reg_field>
2000247c:	4603      	mov	r3, r0
2000247e:	2b00      	cmp	r3, #0
20002480:	d00f      	beq.n	200024a2 <I2C_isr+0x932>
                {
                    HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x00u);
20002482:	687b      	ldr	r3, [r7, #4]
20002484:	681b      	ldr	r3, [r3, #0]
20002486:	4618      	mov	r0, r3
20002488:	f04f 0105 	mov.w	r1, #5
2000248c:	f04f 0220 	mov.w	r2, #32
20002490:	f04f 0300 	mov.w	r3, #0
20002494:	f000 fa77 	bl	20002986 <HW_set_8bit_reg_field>
                    this_i2c->is_transaction_pending = 1u;
20002498:	687b      	ldr	r3, [r7, #4]
2000249a:	f04f 0201 	mov.w	r2, #1
2000249e:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
                 }
            }
            if (this_i2c->slave_tx_idx >= this_i2c->slave_tx_size)
200024a2:	687b      	ldr	r3, [r7, #4]
200024a4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
200024a6:	687b      	ldr	r3, [r7, #4]
200024a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
200024aa:	429a      	cmp	r2, r3
200024ac:	d309      	bcc.n	200024c2 <I2C_isr+0x952>
            {
                /* Ensure 0xFF is returned to the master when the slave specifies
                 * an empty transmit buffer. */
                HAL_set_8bit_reg(this_i2c->base_address, DATA, 0xFFu);
200024ae:	687b      	ldr	r3, [r7, #4]
200024b0:	681b      	ldr	r3, [r3, #0]
200024b2:	f103 0308 	add.w	r3, r3, #8
200024b6:	4618      	mov	r0, r3
200024b8:	f04f 01ff 	mov.w	r1, #255	; 0xff
200024bc:	f000 fa5f 	bl	2000297e <HW_set_8bit_reg>
200024c0:	e011      	b.n	200024e6 <I2C_isr+0x976>
            }
            else
            {
                /* Load the data the data byte to be sent to the master. */
                HAL_set_8bit_reg(this_i2c->base_address, DATA, (uint_fast8_t)this_i2c->slave_tx_buffer[this_i2c->slave_tx_idx++]);
200024c2:	687b      	ldr	r3, [r7, #4]
200024c4:	681b      	ldr	r3, [r3, #0]
200024c6:	f103 0108 	add.w	r1, r3, #8
200024ca:	687b      	ldr	r3, [r7, #4]
200024cc:	6bda      	ldr	r2, [r3, #60]	; 0x3c
200024ce:	687b      	ldr	r3, [r7, #4]
200024d0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200024d2:	441a      	add	r2, r3
200024d4:	7812      	ldrb	r2, [r2, #0]
200024d6:	f103 0001 	add.w	r0, r3, #1
200024da:	687b      	ldr	r3, [r7, #4]
200024dc:	6458      	str	r0, [r3, #68]	; 0x44
200024de:	4608      	mov	r0, r1
200024e0:	4611      	mov	r1, r2
200024e2:	f000 fa4c 	bl	2000297e <HW_set_8bit_reg>
            }
            /* Determine if this is the last data byte to send to the master. */
            if (this_i2c->slave_tx_idx >= this_i2c->slave_tx_size) /* last byte? */
200024e6:	687b      	ldr	r3, [r7, #4]
200024e8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
200024ea:	687b      	ldr	r3, [r7, #4]
200024ec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
200024ee:	429a      	cmp	r2, r3
200024f0:	d36c      	bcc.n	200025cc <I2C_isr+0xa5c>
            {
                 HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u); 
200024f2:	687b      	ldr	r3, [r7, #4]
200024f4:	681b      	ldr	r3, [r3, #0]
200024f6:	4618      	mov	r0, r3
200024f8:	f04f 0102 	mov.w	r1, #2
200024fc:	f04f 0204 	mov.w	r2, #4
20002500:	f04f 0300 	mov.w	r3, #0
20002504:	f000 fa3f 	bl	20002986 <HW_set_8bit_reg_field>
                /* Next read transaction will result in slave's transmit buffer
                 * being sent from the first byte. */
                this_i2c->slave_tx_idx = 0u;
20002508:	687b      	ldr	r3, [r7, #4]
2000250a:	f04f 0200 	mov.w	r2, #0
2000250e:	645a      	str	r2, [r3, #68]	; 0x44
            }
            break;
20002510:	e05d      	b.n	200025ce <I2C_isr+0xa5e>
        case ST_SLAVE_RNACK:    /* Data byte has been transmitted; not-ACK has been received. */
        case ST_FINAL: /* Last Data byte tx'ed, ACK received */
            /* We assume that the transaction will be stopped by the master.
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte. */
            this_i2c->slave_tx_idx = 0u;
20002512:	687b      	ldr	r3, [r7, #4]
20002514:	f04f 0200 	mov.w	r2, #0
20002518:	645a      	str	r2, [r3, #68]	; 0x44
            HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x01u); 
2000251a:	687b      	ldr	r3, [r7, #4]
2000251c:	681b      	ldr	r3, [r3, #0]
2000251e:	4618      	mov	r0, r3
20002520:	f04f 0102 	mov.w	r1, #2
20002524:	f04f 0204 	mov.w	r2, #4
20002528:	f04f 0301 	mov.w	r3, #1
2000252c:	f000 fa2b 	bl	20002986 <HW_set_8bit_reg_field>

            /*  Mark previous state as complete */
            this_i2c->slave_status = I2C_SUCCESS;
20002530:	687b      	ldr	r3, [r7, #4]
20002532:	f04f 0200 	mov.w	r2, #0
20002536:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
2000253a:	687b      	ldr	r3, [r7, #4]
2000253c:	f893 3069 	ldrb.w	r3, [r3, #105]	; 0x69
20002540:	2b00      	cmp	r3, #0
20002542:	d00a      	beq.n	2000255a <I2C_isr+0x9ea>
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
20002544:	687b      	ldr	r3, [r7, #4]
20002546:	681b      	ldr	r3, [r3, #0]
20002548:	4618      	mov	r0, r3
2000254a:	f04f 0105 	mov.w	r1, #5
2000254e:	f04f 0220 	mov.w	r2, #32
20002552:	f04f 0301 	mov.w	r3, #1
20002556:	f000 fa16 	bl	20002986 <HW_set_8bit_reg_field>
            }
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
2000255a:	687b      	ldr	r3, [r7, #4]
2000255c:	f04f 0200 	mov.w	r2, #0
20002560:	731a      	strb	r2, [r3, #12]

            break;
20002562:	e034      	b.n	200025ce <I2C_isr+0xa5e>
        case ST_RESET_ACTIVATED:
        case ST_BUS_ERROR: /* Bus error during MST or selected slave modes */
        default:
            /* Some undefined state has encountered. Clear Start bit to make
             * sure, next good transaction happen */
            HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x00u);
20002564:	687b      	ldr	r3, [r7, #4]
20002566:	681b      	ldr	r3, [r3, #0]
20002568:	4618      	mov	r0, r3
2000256a:	f04f 0105 	mov.w	r1, #5
2000256e:	f04f 0220 	mov.w	r2, #32
20002572:	f04f 0300 	mov.w	r3, #0
20002576:	f000 fa06 	bl	20002986 <HW_set_8bit_reg_field>
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction.
             */
            this_i2c->transaction = NO_TRANSACTION;
2000257a:	687b      	ldr	r3, [r7, #4]
2000257c:	f04f 0200 	mov.w	r2, #0
20002580:	731a      	strb	r2, [r3, #12]
            /*
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte.
             */
            this_i2c->slave_tx_idx = 0u;
20002582:	687b      	ldr	r3, [r7, #4]
20002584:	f04f 0200 	mov.w	r2, #0
20002588:	645a      	str	r2, [r3, #68]	; 0x44
            /*
             * Clear statuses to I2C_FAILED only if there was an operation in progress.
             */
            if(I2C_IN_PROGRESS == this_i2c->master_status)
2000258a:	687b      	ldr	r3, [r7, #4]
2000258c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
20002590:	b2db      	uxtb	r3, r3
20002592:	2b01      	cmp	r3, #1
20002594:	d104      	bne.n	200025a0 <I2C_isr+0xa30>
            {
                this_i2c->master_status = I2C_FAILED;
20002596:	687b      	ldr	r3, [r7, #4]
20002598:	f04f 0202 	mov.w	r2, #2
2000259c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            }

            if(I2C_IN_PROGRESS == this_i2c->slave_status)
200025a0:	687b      	ldr	r3, [r7, #4]
200025a2:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
200025a6:	b2db      	uxtb	r3, r3
200025a8:	2b01      	cmp	r3, #1
200025aa:	d110      	bne.n	200025ce <I2C_isr+0xa5e>
            {
                this_i2c->slave_status = I2C_FAILED;
200025ac:	687b      	ldr	r3, [r7, #4]
200025ae:	f04f 0202 	mov.w	r2, #2
200025b2:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
200025b6:	e00a      	b.n	200025ce <I2C_isr+0xa5e>
              HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
              break;

        case ST_STOP_TRANSMIT:
             /* Stop has been transmitted. Do nothing */
              break;
200025b8:	bf00      	nop
200025ba:	e008      	b.n	200025ce <I2C_isr+0xa5e>
             */
            if(this_i2c->transaction != this_i2c->pending_transaction)
            {
                this_i2c->transaction = this_i2c->pending_transaction;
            }
            break;
200025bc:	bf00      	nop
200025be:	e006      	b.n	200025ce <I2C_isr+0xa5e>
            {
                /* If we're at the second last byte, let's set AA to 0 so
                 * we return a NACK at the last byte. */
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u);
            }
            break;
200025c0:	bf00      	nop
200025c2:	e004      	b.n	200025ce <I2C_isr+0xa5e>
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
            {
                HAL_set_8bit_reg_field(this_i2c->base_address, STA, 0x01u);
            }
            break;
200025c4:	bf00      	nop
200025c6:	e002      	b.n	200025ce <I2C_isr+0xa5e>
            if(this_i2c->slave_rx_idx >= this_i2c->slave_rx_size)
            {
                /* Rx buffer is full. NACK next received byte. */
                HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u); 
            }
            break;
200025c8:	bf00      	nop
200025ca:	e000      	b.n	200025ce <I2C_isr+0xa5e>
                 HAL_set_8bit_reg_field(this_i2c->base_address, AA, 0x00u); 
                /* Next read transaction will result in slave's transmit buffer
                 * being sent from the first byte. */
                this_i2c->slave_tx_idx = 0u;
            }
            break;
200025cc:	bf00      	nop
            }

            break;
    }
    
    if ( clear_irq )
200025ce:	7bbb      	ldrb	r3, [r7, #14]
200025d0:	2b00      	cmp	r3, #0
200025d2:	d00a      	beq.n	200025ea <I2C_isr+0xa7a>
    {
        /* clear interrupt. */
        HAL_set_8bit_reg_field(this_i2c->base_address, SI, 0x00u);
200025d4:	687b      	ldr	r3, [r7, #4]
200025d6:	681b      	ldr	r3, [r3, #0]
200025d8:	4618      	mov	r0, r3
200025da:	f04f 0103 	mov.w	r1, #3
200025de:	f04f 0208 	mov.w	r2, #8
200025e2:	f04f 0300 	mov.w	r3, #0
200025e6:	f000 f9ce 	bl	20002986 <HW_set_8bit_reg_field>
    }
    
    /* Read the status register to ensure the last I2C registers write took place
     * in a system built around a bus making use of posted writes. */
    status = HAL_get_8bit_reg( this_i2c->base_address, STATUS);
200025ea:	687b      	ldr	r3, [r7, #4]
200025ec:	681b      	ldr	r3, [r3, #0]
200025ee:	f103 0304 	add.w	r3, r3, #4
200025f2:	4618      	mov	r0, r3
200025f4:	f000 f9c5 	bl	20002982 <HW_get_8bit_reg>
200025f8:	4603      	mov	r3, r0
200025fa:	72fb      	strb	r3, [r7, #11]
}
200025fc:	f107 0710 	add.w	r7, r7, #16
20002600:	46bd      	mov	sp, r7
20002602:	bdb0      	pop	{r4, r5, r7, pc}

20002604 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20002604:	b480      	push	{r7}
20002606:	b083      	sub	sp, #12
20002608:	af00      	add	r7, sp, #0
2000260a:	4603      	mov	r3, r0
2000260c:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
2000260e:	f24e 1300 	movw	r3, #57600	; 0xe100
20002612:	f2ce 0300 	movt	r3, #57344	; 0xe000
20002616:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000261a:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000261e:	79f9      	ldrb	r1, [r7, #7]
20002620:	f001 011f 	and.w	r1, r1, #31
20002624:	f04f 0001 	mov.w	r0, #1
20002628:	fa00 f101 	lsl.w	r1, r0, r1
2000262c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20002630:	f107 070c 	add.w	r7, r7, #12
20002634:	46bd      	mov	sp, r7
20002636:	bc80      	pop	{r7}
20002638:	4770      	bx	lr
2000263a:	bf00      	nop

2000263c <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
2000263c:	b480      	push	{r7}
2000263e:	b083      	sub	sp, #12
20002640:	af00      	add	r7, sp, #0
20002642:	4603      	mov	r3, r0
20002644:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
20002646:	f24e 1300 	movw	r3, #57600	; 0xe100
2000264a:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000264e:	f997 2007 	ldrsb.w	r2, [r7, #7]
20002652:	ea4f 1252 	mov.w	r2, r2, lsr #5
20002656:	79f9      	ldrb	r1, [r7, #7]
20002658:	f001 011f 	and.w	r1, r1, #31
2000265c:	f04f 0001 	mov.w	r0, #1
20002660:	fa00 f101 	lsl.w	r1, r0, r1
20002664:	f102 0220 	add.w	r2, r2, #32
20002668:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
2000266c:	f107 070c 	add.w	r7, r7, #12
20002670:	46bd      	mov	sp, r7
20002672:	bc80      	pop	{r7}
20002674:	4770      	bx	lr
20002676:	bf00      	nop

20002678 <I2C_enable_irq>:
/*------------------------------------------------------------------------------
 * This function must be modified to enable interrupts generated from the
 * CoreI2C instance identified as parameter.
 */
void I2C_enable_irq( i2c_instance_t * this_i2c )
{
20002678:	b580      	push	{r7, lr}
2000267a:	b082      	sub	sp, #8
2000267c:	af00      	add	r7, sp, #0
2000267e:	6078      	str	r0, [r7, #4]
    //HAL_ASSERT(0)
	if(this_i2c == &g_core_i2c0)
20002680:	687a      	ldr	r2, [r7, #4]
20002682:	f243 039c 	movw	r3, #12444	; 0x309c
20002686:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000268a:	429a      	cmp	r2, r3
2000268c:	d103      	bne.n	20002696 <I2C_enable_irq+0x1e>
	{
		NVIC_EnableIRQ( FabricIrq0_IRQn );
2000268e:	f04f 0022 	mov.w	r0, #34	; 0x22
20002692:	f7ff ffb7 	bl	20002604 <NVIC_EnableIRQ>
	}

	if(this_i2c == &g_core_i2c1)
20002696:	687a      	ldr	r2, [r7, #4]
20002698:	f243 1308 	movw	r3, #12552	; 0x3108
2000269c:	f2c2 0300 	movt	r3, #8192	; 0x2000
200026a0:	429a      	cmp	r2, r3
200026a2:	d103      	bne.n	200026ac <I2C_enable_irq+0x34>
	{
		NVIC_EnableIRQ( FabricIrq1_IRQn );
200026a4:	f04f 0023 	mov.w	r0, #35	; 0x23
200026a8:	f7ff ffac 	bl	20002604 <NVIC_EnableIRQ>
	}
	if(this_i2c == &g_core_i2c2)
200026ac:	687a      	ldr	r2, [r7, #4]
200026ae:	f642 33ec 	movw	r3, #11244	; 0x2bec
200026b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200026b6:	429a      	cmp	r2, r3
200026b8:	d103      	bne.n	200026c2 <I2C_enable_irq+0x4a>
	{
		NVIC_EnableIRQ( FabricIrq2_IRQn );
200026ba:	f04f 0024 	mov.w	r0, #36	; 0x24
200026be:	f7ff ffa1 	bl	20002604 <NVIC_EnableIRQ>
	}
	if(this_i2c == &g_core_i2c3)
200026c2:	687a      	ldr	r2, [r7, #4]
200026c4:	f243 13e0 	movw	r3, #12768	; 0x31e0
200026c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200026cc:	429a      	cmp	r2, r3
200026ce:	d103      	bne.n	200026d8 <I2C_enable_irq+0x60>
	{
		NVIC_EnableIRQ( FabricIrq3_IRQn );
200026d0:	f04f 0025 	mov.w	r0, #37	; 0x25
200026d4:	f7ff ff96 	bl	20002604 <NVIC_EnableIRQ>
	}
	if(this_i2c == &g_core_i2c4)
200026d8:	687a      	ldr	r2, [r7, #4]
200026da:	f243 2354 	movw	r3, #12884	; 0x3254
200026de:	f2c2 0300 	movt	r3, #8192	; 0x2000
200026e2:	429a      	cmp	r2, r3
200026e4:	d103      	bne.n	200026ee <I2C_enable_irq+0x76>
	{
		NVIC_EnableIRQ( FabricIrq4_IRQn );
200026e6:	f04f 0026 	mov.w	r0, #38	; 0x26
200026ea:	f7ff ff8b 	bl	20002604 <NVIC_EnableIRQ>
	}
	if(this_i2c == &g_core_i2c5)
200026ee:	687a      	ldr	r2, [r7, #4]
200026f0:	f243 1374 	movw	r3, #12660	; 0x3174
200026f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200026f8:	429a      	cmp	r2, r3
200026fa:	d103      	bne.n	20002704 <I2C_enable_irq+0x8c>
	{
		NVIC_EnableIRQ( FabricIrq5_IRQn );
200026fc:	f04f 0027 	mov.w	r0, #39	; 0x27
20002700:	f7ff ff80 	bl	20002604 <NVIC_EnableIRQ>
	}
}
20002704:	f107 0708 	add.w	r7, r7, #8
20002708:	46bd      	mov	sp, r7
2000270a:	bd80      	pop	{r7, pc}

2000270c <I2C_disable_irq>:
/*------------------------------------------------------------------------------
 * This function must be modified to disable interrupts generated from the
 * CoreI2C instance identified as parameter.
 */
void I2C_disable_irq( i2c_instance_t * this_i2c )
{
2000270c:	b580      	push	{r7, lr}
2000270e:	b082      	sub	sp, #8
20002710:	af00      	add	r7, sp, #0
20002712:	6078      	str	r0, [r7, #4]
    //HAL_ASSERT(0)
	if(this_i2c == &g_core_i2c0)
20002714:	687a      	ldr	r2, [r7, #4]
20002716:	f243 039c 	movw	r3, #12444	; 0x309c
2000271a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000271e:	429a      	cmp	r2, r3
20002720:	d103      	bne.n	2000272a <I2C_disable_irq+0x1e>
	{
		NVIC_DisableIRQ( FabricIrq0_IRQn );
20002722:	f04f 0022 	mov.w	r0, #34	; 0x22
20002726:	f7ff ff89 	bl	2000263c <NVIC_DisableIRQ>
	}

	if(this_i2c == &g_core_i2c1)
2000272a:	687a      	ldr	r2, [r7, #4]
2000272c:	f243 1308 	movw	r3, #12552	; 0x3108
20002730:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002734:	429a      	cmp	r2, r3
20002736:	d103      	bne.n	20002740 <I2C_disable_irq+0x34>
	{
		NVIC_DisableIRQ( FabricIrq1_IRQn );
20002738:	f04f 0023 	mov.w	r0, #35	; 0x23
2000273c:	f7ff ff7e 	bl	2000263c <NVIC_DisableIRQ>
	}

	if(this_i2c == &g_core_i2c2)
20002740:	687a      	ldr	r2, [r7, #4]
20002742:	f642 33ec 	movw	r3, #11244	; 0x2bec
20002746:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000274a:	429a      	cmp	r2, r3
2000274c:	d103      	bne.n	20002756 <I2C_disable_irq+0x4a>
	{
		NVIC_DisableIRQ( FabricIrq2_IRQn );
2000274e:	f04f 0024 	mov.w	r0, #36	; 0x24
20002752:	f7ff ff73 	bl	2000263c <NVIC_DisableIRQ>
	}

	if(this_i2c == &g_core_i2c3)
20002756:	687a      	ldr	r2, [r7, #4]
20002758:	f243 13e0 	movw	r3, #12768	; 0x31e0
2000275c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002760:	429a      	cmp	r2, r3
20002762:	d103      	bne.n	2000276c <I2C_disable_irq+0x60>
	{
		NVIC_DisableIRQ( FabricIrq3_IRQn );
20002764:	f04f 0025 	mov.w	r0, #37	; 0x25
20002768:	f7ff ff68 	bl	2000263c <NVIC_DisableIRQ>
	}

	if(this_i2c == &g_core_i2c4)
2000276c:	687a      	ldr	r2, [r7, #4]
2000276e:	f243 2354 	movw	r3, #12884	; 0x3254
20002772:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002776:	429a      	cmp	r2, r3
20002778:	d103      	bne.n	20002782 <I2C_disable_irq+0x76>
	{
		NVIC_DisableIRQ( FabricIrq4_IRQn );
2000277a:	f04f 0026 	mov.w	r0, #38	; 0x26
2000277e:	f7ff ff5d 	bl	2000263c <NVIC_DisableIRQ>
	}

	if(this_i2c == &g_core_i2c5)
20002782:	687a      	ldr	r2, [r7, #4]
20002784:	f243 1374 	movw	r3, #12660	; 0x3174
20002788:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000278c:	429a      	cmp	r2, r3
2000278e:	d103      	bne.n	20002798 <I2C_disable_irq+0x8c>
	{
		NVIC_DisableIRQ( FabricIrq5_IRQn );
20002790:	f04f 0027 	mov.w	r0, #39	; 0x27
20002794:	f7ff ff52 	bl	2000263c <NVIC_DisableIRQ>
	}
}
20002798:	f107 0708 	add.w	r7, r7, #8
2000279c:	46bd      	mov	sp, r7
2000279e:	bd80      	pop	{r7, pc}

200027a0 <SystemInit>:

/***************************************************************************//**
 * See system_m2sxxx.h for details.
 */
void SystemInit(void)
{
200027a0:	b580      	push	{r7, lr}
200027a2:	af00      	add	r7, sp, #0
     * Do not make use of global variables or make any asumptions regarding
     * memory content if modifying this function. The memory content has not been
     * initialised by the time this function is called by the start-up code.
     */
#if (MSS_SYS_FACC_INIT_BY_CORTEX == 1)
    complete_clock_config();
200027a4:	f000 f86c 	bl	20002880 <complete_clock_config>
#endif

    silicon_workarounds();
200027a8:	f000 f838 	bl	2000281c <silicon_workarounds>
    /*--------------------------------------------------------------------------
     * Set STKALIGN to ensure exception stacking starts on 8 bytes address
     * boundary. This ensures compliance with the "Procedure Call Standards for
     * the ARM Architecture" (AAPCS).
     */
    SCB->CCR |= SCB_CCR_STKALIGN_Msk;
200027ac:	f64e 5300 	movw	r3, #60672	; 0xed00
200027b0:	f2ce 0300 	movt	r3, #57344	; 0xe000
200027b4:	f64e 5200 	movw	r2, #60672	; 0xed00
200027b8:	f2ce 0200 	movt	r2, #57344	; 0xe000
200027bc:	6952      	ldr	r2, [r2, #20]
200027be:	f442 7200 	orr.w	r2, r2, #512	; 0x200
200027c2:	615a      	str	r2, [r3, #20]
#endif

    /*--------------------------------------------------------------------------
     * Call user defined configuration function.
     */
    mscc_post_hw_cfg_init();
200027c4:	f7fd fd73 	bl	200002ae <mscc_post_hw_cfg_init>
    while(!CORE_SF2_CFG->INIT_DONE)
    {
        ;   /* Wait for INIT_DONE from CoreSF2Reset. */
    }
#endif
}
200027c8:	bd80      	pop	{r7, pc}
200027ca:	bf00      	nop

200027cc <get_silicon_revision>:

/*------------------------------------------------------------------------------
  Retrieve silicon revision from system registers.
 */
static uint32_t get_silicon_revision(void)
{
200027cc:	b480      	push	{r7}
200027ce:	b083      	sub	sp, #12
200027d0:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;
    uint32_t device_version;
    
    device_version = SYSREG->DEVICE_VERSION;
200027d2:	f248 0300 	movw	r3, #32768	; 0x8000
200027d6:	f2c4 0303 	movt	r3, #16387	; 0x4003
200027da:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
200027de:	607b      	str	r3, [r7, #4]
    switch(device_version)
200027e0:	687a      	ldr	r2, [r7, #4]
200027e2:	f64f 0302 	movw	r3, #63490	; 0xf802
200027e6:	429a      	cmp	r2, r3
200027e8:	d006      	beq.n	200027f8 <get_silicon_revision+0x2c>
200027ea:	f64f 0302 	movw	r3, #63490	; 0xf802
200027ee:	f2c0 0301 	movt	r3, #1
200027f2:	429a      	cmp	r2, r3
200027f4:	d004      	beq.n	20002800 <get_silicon_revision+0x34>
200027f6:	e007      	b.n	20002808 <get_silicon_revision+0x3c>
    {
        case 0x0000F802:
            silicon_revision = M2S050_REV_A_SILICON;
200027f8:	f04f 0301 	mov.w	r3, #1
200027fc:	603b      	str	r3, [r7, #0]
            break;
200027fe:	e006      	b.n	2000280e <get_silicon_revision+0x42>
            
        case 0x0001F802:
            silicon_revision = M2S050_REV_B_SILICON;
20002800:	f04f 0302 	mov.w	r3, #2
20002804:	603b      	str	r3, [r7, #0]
            break;
20002806:	e002      	b.n	2000280e <get_silicon_revision+0x42>
            
        default:
            silicon_revision = UNKNOWN_SILICON_REV;
20002808:	f04f 0300 	mov.w	r3, #0
2000280c:	603b      	str	r3, [r7, #0]
            break;
    }
    
    return silicon_revision;
2000280e:	683b      	ldr	r3, [r7, #0]
}
20002810:	4618      	mov	r0, r3
20002812:	f107 070c 	add.w	r7, r7, #12
20002816:	46bd      	mov	sp, r7
20002818:	bc80      	pop	{r7}
2000281a:	4770      	bx	lr

2000281c <silicon_workarounds>:

/*------------------------------------------------------------------------------
  Workarounds for various silicon versions.
 */
static void silicon_workarounds(void)
{
2000281c:	b580      	push	{r7, lr}
2000281e:	b082      	sub	sp, #8
20002820:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;
    
    silicon_revision = get_silicon_revision();
20002822:	f7ff ffd3 	bl	200027cc <get_silicon_revision>
20002826:	4603      	mov	r3, r0
20002828:	607b      	str	r3, [r7, #4]
    
    switch(silicon_revision)
2000282a:	687b      	ldr	r3, [r7, #4]
2000282c:	2b01      	cmp	r3, #1
2000282e:	d101      	bne.n	20002834 <silicon_workarounds+0x18>
    {
        case M2S050_REV_A_SILICON:
            m2s050_rev_a_workarounds();
20002830:	f000 f804 	bl	2000283c <m2s050_rev_a_workarounds>
        case UNKNOWN_SILICON_REV:
            /* Fall through. */
        default:
            break;
    }
}
20002834:	f107 0708 	add.w	r7, r7, #8
20002838:	46bd      	mov	sp, r7
2000283a:	bd80      	pop	{r7, pc}

2000283c <m2s050_rev_a_workarounds>:

/*------------------------------------------------------------------------------
  Silicon workarounds for M2S050 rev A.
 */
static void m2s050_rev_a_workarounds(void)
{
2000283c:	b480      	push	{r7}
2000283e:	af00      	add	r7, sp, #0
    /*--------------------------------------------------------------------------
     * Work around a couple of silicon issues:
     */
    /* DDR_CLK_EN <- 1 */
    SYSREG->MSSDDR_FACC1_CR |= (uint32_t)1 << DDR_CLK_EN_SHIFT;
20002840:	f248 0300 	movw	r3, #32768	; 0x8000
20002844:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002848:	f248 0200 	movw	r2, #32768	; 0x8000
2000284c:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002850:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
20002854:	f442 7280 	orr.w	r2, r2, #256	; 0x100
20002858:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    
    /* CONTROLLER_PLL_INIT <- 0 */
    SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & ~CONTROLLER_PLL_INIT_MASK;
2000285c:	f248 0300 	movw	r3, #32768	; 0x8000
20002860:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002864:	f248 0200 	movw	r2, #32768	; 0x8000
20002868:	f2c4 0203 	movt	r2, #16387	; 0x4003
2000286c:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
20002870:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
20002874:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
}
20002878:	46bd      	mov	sp, r7
2000287a:	bc80      	pop	{r7}
2000287c:	4770      	bx	lr
2000287e:	bf00      	nop

20002880 <complete_clock_config>:
/*------------------------------------------------------------------------------
  Complete clock configuration if requested by Libero.
 */
#if (MSS_SYS_FACC_INIT_BY_CORTEX == 1)
static void complete_clock_config(void)
{
20002880:	b480      	push	{r7}
20002882:	b083      	sub	sp, #12
20002884:	af00      	add	r7, sp, #0
    uint32_t pll_locked;
    
    /* Wait for fabric PLL to lock. */
    do {
        pll_locked = SYSREG->MSSDDR_PLL_STATUS & FAB_PLL_LOCK_MASK;
20002886:	f248 0300 	movw	r3, #32768	; 0x8000
2000288a:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000288e:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
20002892:	f003 0301 	and.w	r3, r3, #1
20002896:	607b      	str	r3, [r7, #4]
    } while(!pll_locked);
20002898:	687b      	ldr	r3, [r7, #4]
2000289a:	2b00      	cmp	r3, #0
2000289c:	d0f3      	beq.n	20002886 <complete_clock_config+0x6>
    
    /* Negate MPLL bypass. */
    SYSREG->MSSDDR_PLL_STATUS_HIGH_CR &= ~FACC_PLL_BYPASS_MASK;
2000289e:	f248 0300 	movw	r3, #32768	; 0x8000
200028a2:	f2c4 0303 	movt	r3, #16387	; 0x4003
200028a6:	f248 0200 	movw	r2, #32768	; 0x8000
200028aa:	f2c4 0203 	movt	r2, #16387	; 0x4003
200028ae:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
200028b2:	f022 0201 	bic.w	r2, r2, #1
200028b6:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    
    /* Wait for MPLL to lock. */
    do {
        pll_locked = SYSREG->MSSDDR_PLL_STATUS & MPLL_LOCK_MASK;
200028ba:	f248 0300 	movw	r3, #32768	; 0x8000
200028be:	f2c4 0303 	movt	r3, #16387	; 0x4003
200028c2:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
200028c6:	f003 0302 	and.w	r3, r3, #2
200028ca:	607b      	str	r3, [r7, #4]
    } while(!pll_locked);
200028cc:	687b      	ldr	r3, [r7, #4]
200028ce:	2b00      	cmp	r3, #0
200028d0:	d0f3      	beq.n	200028ba <complete_clock_config+0x3a>
    
    /* Switch FACC from standby to run mode. */
    SYSREG->MSSDDR_FACC1_CR &= ~FACC_GLMUX_SEL_MASK;
200028d2:	f248 0300 	movw	r3, #32768	; 0x8000
200028d6:	f2c4 0303 	movt	r3, #16387	; 0x4003
200028da:	f248 0200 	movw	r2, #32768	; 0x8000
200028de:	f2c4 0203 	movt	r2, #16387	; 0x4003
200028e2:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
200028e6:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
200028ea:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

    /* Negate FPGA_SOFTRESET to de-assert MSS_RESET_N_M2F in the fabric */
    SYSREG->SOFT_RST_CR &= ~SYSREG_FPGA_SOFTRESET_MASK;
200028ee:	f248 0300 	movw	r3, #32768	; 0x8000
200028f2:	f2c4 0303 	movt	r3, #16387	; 0x4003
200028f6:	f248 0200 	movw	r2, #32768	; 0x8000
200028fa:	f2c4 0203 	movt	r2, #16387	; 0x4003
200028fe:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002900:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
20002904:	649a      	str	r2, [r3, #72]	; 0x48
}
20002906:	f107 070c 	add.w	r7, r7, #12
2000290a:	46bd      	mov	sp, r7
2000290c:	bc80      	pop	{r7}
2000290e:	4770      	bx	lr

20002910 <HAL_disable_interrupts>:
20002910:	f3ef 8010 	mrs	r0, PRIMASK
20002914:	b672      	cpsid	i
20002916:	4770      	bx	lr

20002918 <HAL_restore_interrupts>:
20002918:	f380 8810 	msr	PRIMASK, r0
2000291c:	4770      	bx	lr

2000291e <HW_set_32bit_reg>:
2000291e:	6001      	str	r1, [r0, #0]
20002920:	4770      	bx	lr

20002922 <HW_get_32bit_reg>:
20002922:	6800      	ldr	r0, [r0, #0]
20002924:	4770      	bx	lr

20002926 <HW_set_32bit_reg_field>:
20002926:	b50e      	push	{r1, r2, r3, lr}
20002928:	fa03 f301 	lsl.w	r3, r3, r1
2000292c:	ea03 0302 	and.w	r3, r3, r2
20002930:	6801      	ldr	r1, [r0, #0]
20002932:	ea6f 0202 	mvn.w	r2, r2
20002936:	ea01 0102 	and.w	r1, r1, r2
2000293a:	ea41 0103 	orr.w	r1, r1, r3
2000293e:	6001      	str	r1, [r0, #0]
20002940:	bd0e      	pop	{r1, r2, r3, pc}

20002942 <HW_get_32bit_reg_field>:
20002942:	6800      	ldr	r0, [r0, #0]
20002944:	ea00 0002 	and.w	r0, r0, r2
20002948:	fa20 f001 	lsr.w	r0, r0, r1
2000294c:	4770      	bx	lr

2000294e <HW_set_16bit_reg>:
2000294e:	8001      	strh	r1, [r0, #0]
20002950:	4770      	bx	lr

20002952 <HW_get_16bit_reg>:
20002952:	8800      	ldrh	r0, [r0, #0]
20002954:	4770      	bx	lr

20002956 <HW_set_16bit_reg_field>:
20002956:	b50e      	push	{r1, r2, r3, lr}
20002958:	fa03 f301 	lsl.w	r3, r3, r1
2000295c:	ea03 0302 	and.w	r3, r3, r2
20002960:	8801      	ldrh	r1, [r0, #0]
20002962:	ea6f 0202 	mvn.w	r2, r2
20002966:	ea01 0102 	and.w	r1, r1, r2
2000296a:	ea41 0103 	orr.w	r1, r1, r3
2000296e:	8001      	strh	r1, [r0, #0]
20002970:	bd0e      	pop	{r1, r2, r3, pc}

20002972 <HW_get_16bit_reg_field>:
20002972:	8800      	ldrh	r0, [r0, #0]
20002974:	ea00 0002 	and.w	r0, r0, r2
20002978:	fa20 f001 	lsr.w	r0, r0, r1
2000297c:	4770      	bx	lr

2000297e <HW_set_8bit_reg>:
2000297e:	7001      	strb	r1, [r0, #0]
20002980:	4770      	bx	lr

20002982 <HW_get_8bit_reg>:
20002982:	7800      	ldrb	r0, [r0, #0]
20002984:	4770      	bx	lr

20002986 <HW_set_8bit_reg_field>:
20002986:	b50e      	push	{r1, r2, r3, lr}
20002988:	fa03 f301 	lsl.w	r3, r3, r1
2000298c:	ea03 0302 	and.w	r3, r3, r2
20002990:	7801      	ldrb	r1, [r0, #0]
20002992:	ea6f 0202 	mvn.w	r2, r2
20002996:	ea01 0102 	and.w	r1, r1, r2
2000299a:	ea41 0103 	orr.w	r1, r1, r3
2000299e:	7001      	strb	r1, [r0, #0]
200029a0:	bd0e      	pop	{r1, r2, r3, pc}

200029a2 <HW_get_8bit_reg_field>:
200029a2:	7800      	ldrb	r0, [r0, #0]
200029a4:	ea00 0002 	and.w	r0, r0, r2
200029a8:	fa20 f001 	lsr.w	r0, r0, r1
200029ac:	4770      	bx	lr
	...

200029b0 <__libc_init_array>:
200029b0:	b570      	push	{r4, r5, r6, lr}
200029b2:	f642 3608 	movw	r6, #11016	; 0x2b08
200029b6:	f642 3508 	movw	r5, #11016	; 0x2b08
200029ba:	f2c2 0600 	movt	r6, #8192	; 0x2000
200029be:	f2c2 0500 	movt	r5, #8192	; 0x2000
200029c2:	1b76      	subs	r6, r6, r5
200029c4:	10b6      	asrs	r6, r6, #2
200029c6:	d006      	beq.n	200029d6 <__libc_init_array+0x26>
200029c8:	2400      	movs	r4, #0
200029ca:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
200029ce:	3401      	adds	r4, #1
200029d0:	4798      	blx	r3
200029d2:	42a6      	cmp	r6, r4
200029d4:	d8f9      	bhi.n	200029ca <__libc_init_array+0x1a>
200029d6:	f642 3508 	movw	r5, #11016	; 0x2b08
200029da:	f642 360c 	movw	r6, #11020	; 0x2b0c
200029de:	f2c2 0500 	movt	r5, #8192	; 0x2000
200029e2:	f2c2 0600 	movt	r6, #8192	; 0x2000
200029e6:	1b76      	subs	r6, r6, r5
200029e8:	f000 f882 	bl	20002af0 <_init>
200029ec:	10b6      	asrs	r6, r6, #2
200029ee:	d006      	beq.n	200029fe <__libc_init_array+0x4e>
200029f0:	2400      	movs	r4, #0
200029f2:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
200029f6:	3401      	adds	r4, #1
200029f8:	4798      	blx	r3
200029fa:	42a6      	cmp	r6, r4
200029fc:	d8f9      	bhi.n	200029f2 <__libc_init_array+0x42>
200029fe:	bd70      	pop	{r4, r5, r6, pc}

20002a00 <memset>:
20002a00:	2a03      	cmp	r2, #3
20002a02:	b2c9      	uxtb	r1, r1
20002a04:	b430      	push	{r4, r5}
20002a06:	d807      	bhi.n	20002a18 <memset+0x18>
20002a08:	b122      	cbz	r2, 20002a14 <memset+0x14>
20002a0a:	2300      	movs	r3, #0
20002a0c:	54c1      	strb	r1, [r0, r3]
20002a0e:	3301      	adds	r3, #1
20002a10:	4293      	cmp	r3, r2
20002a12:	d1fb      	bne.n	20002a0c <memset+0xc>
20002a14:	bc30      	pop	{r4, r5}
20002a16:	4770      	bx	lr
20002a18:	eb00 0c02 	add.w	ip, r0, r2
20002a1c:	4603      	mov	r3, r0
20002a1e:	e001      	b.n	20002a24 <memset+0x24>
20002a20:	f803 1c01 	strb.w	r1, [r3, #-1]
20002a24:	f003 0403 	and.w	r4, r3, #3
20002a28:	461a      	mov	r2, r3
20002a2a:	3301      	adds	r3, #1
20002a2c:	2c00      	cmp	r4, #0
20002a2e:	d1f7      	bne.n	20002a20 <memset+0x20>
20002a30:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
20002a34:	ebc2 040c 	rsb	r4, r2, ip
20002a38:	fb03 f301 	mul.w	r3, r3, r1
20002a3c:	e01f      	b.n	20002a7e <memset+0x7e>
20002a3e:	f842 3c40 	str.w	r3, [r2, #-64]
20002a42:	f842 3c3c 	str.w	r3, [r2, #-60]
20002a46:	f842 3c38 	str.w	r3, [r2, #-56]
20002a4a:	f842 3c34 	str.w	r3, [r2, #-52]
20002a4e:	f842 3c30 	str.w	r3, [r2, #-48]
20002a52:	f842 3c2c 	str.w	r3, [r2, #-44]
20002a56:	f842 3c28 	str.w	r3, [r2, #-40]
20002a5a:	f842 3c24 	str.w	r3, [r2, #-36]
20002a5e:	f842 3c20 	str.w	r3, [r2, #-32]
20002a62:	f842 3c1c 	str.w	r3, [r2, #-28]
20002a66:	f842 3c18 	str.w	r3, [r2, #-24]
20002a6a:	f842 3c14 	str.w	r3, [r2, #-20]
20002a6e:	f842 3c10 	str.w	r3, [r2, #-16]
20002a72:	f842 3c0c 	str.w	r3, [r2, #-12]
20002a76:	f842 3c08 	str.w	r3, [r2, #-8]
20002a7a:	f842 3c04 	str.w	r3, [r2, #-4]
20002a7e:	4615      	mov	r5, r2
20002a80:	3240      	adds	r2, #64	; 0x40
20002a82:	2c3f      	cmp	r4, #63	; 0x3f
20002a84:	f1a4 0440 	sub.w	r4, r4, #64	; 0x40
20002a88:	dcd9      	bgt.n	20002a3e <memset+0x3e>
20002a8a:	462a      	mov	r2, r5
20002a8c:	ebc5 040c 	rsb	r4, r5, ip
20002a90:	e007      	b.n	20002aa2 <memset+0xa2>
20002a92:	f842 3c10 	str.w	r3, [r2, #-16]
20002a96:	f842 3c0c 	str.w	r3, [r2, #-12]
20002a9a:	f842 3c08 	str.w	r3, [r2, #-8]
20002a9e:	f842 3c04 	str.w	r3, [r2, #-4]
20002aa2:	4615      	mov	r5, r2
20002aa4:	3210      	adds	r2, #16
20002aa6:	2c0f      	cmp	r4, #15
20002aa8:	f1a4 0410 	sub.w	r4, r4, #16
20002aac:	dcf1      	bgt.n	20002a92 <memset+0x92>
20002aae:	462a      	mov	r2, r5
20002ab0:	ebc5 050c 	rsb	r5, r5, ip
20002ab4:	e001      	b.n	20002aba <memset+0xba>
20002ab6:	f842 3c04 	str.w	r3, [r2, #-4]
20002aba:	4614      	mov	r4, r2
20002abc:	3204      	adds	r2, #4
20002abe:	2d03      	cmp	r5, #3
20002ac0:	f1a5 0504 	sub.w	r5, r5, #4
20002ac4:	dcf7      	bgt.n	20002ab6 <memset+0xb6>
20002ac6:	e001      	b.n	20002acc <memset+0xcc>
20002ac8:	f804 1b01 	strb.w	r1, [r4], #1
20002acc:	4564      	cmp	r4, ip
20002ace:	d3fb      	bcc.n	20002ac8 <memset+0xc8>
20002ad0:	e7a0      	b.n	20002a14 <memset+0x14>
20002ad2:	bf00      	nop

20002ad4 <C.135.6324>:
20002ad4:	0038 0005                                   8...

20002ad8 <C.136.6325>:
20002ad8:	0020 003f                                    .?.

20002adc <C.137.6326>:
20002adc:	0030 000f                                   0...

20002ae0 <C.138.6327>:
20002ae0:	0028 0001                                   (...

20002ae4 <C.142.6331>:
20002ae4:	1118 0000                                   ....

20002ae8 <C.143.6332>:
20002ae8:	ff10 00f0                                   ....

20002aec <C.144.6333>:
20002aec:	ee18 00e0                                   ....

20002af0 <_init>:
20002af0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20002af2:	bf00      	nop
20002af4:	bcf8      	pop	{r3, r4, r5, r6, r7}
20002af6:	bc08      	pop	{r3}
20002af8:	469e      	mov	lr, r3
20002afa:	4770      	bx	lr

20002afc <_fini>:
20002afc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20002afe:	bf00      	nop
20002b00:	bcf8      	pop	{r3, r4, r5, r6, r7}
20002b02:	bc08      	pop	{r3}
20002b04:	469e      	mov	lr, r3
20002b06:	4770      	bx	lr

20002b08 <__frame_dummy_init_array_entry>:
20002b08:	0305 2000                                   ... 

20002b0c <__do_global_dtors_aux_fini_array_entry>:
20002b0c:	02f1 2000                                   ... 
